CCS PCD C Compiler, Version 5.015, 5967               26-Oct-16 01:06

               Filename:   D:\Work\Class Projects\3rd Year\Term1\Cookies\MPLABX\Version1\LowLevel.X\build\default\production\main.lst

               ROM used:   5504 bytes (16%)
                           Largest free fragment is 28284
               RAM used:   259 (3%) at main() level
                           386 (5%) worst case
               Stack size: 128

*
0000:  GOTO    138E
*
0014:  DATA    AC,09,00
*
002A:  DATA    6A,02,00
*
003C:  DATA    6E,0A,00
.................... #include <24FJ48GA002.h> 
.................... //////////// Standard Header file for the PIC24FJ48GA002 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24FJ48GA002 
*
0200:  CLR     32
0202:  MOV     #20C,W3
0204:  ADD     W3,W0,W0
0206:  TBLRDL.B[W0],W0L
0208:  CLR.B   1
020A:  RETURN  
020C:  DATA    4D,61,00
020E:  DATA    69,6E,00
0210:  DATA    0D,0A,00
0212:  DATA    00,00,00
*
029A:  MOV     W5,[W15++]
029C:  MOV     #C,W5
029E:  REPEAT  #3
02A0:  MOV     [W5++],[W15++]
02A2:  MOV     W0,W4
02A4:  MOV     W1,W5
02A6:  MOV     W2,W6
02A8:  MOV     W3,W7
02AA:  CLR     W0
02AC:  CLR     W1
02AE:  CLR     W2
02B0:  CLR     W3
02B2:  BCLR    W8.0
02B4:  BTSS    W7.F
02B6:  BRA     2C2
02B8:  BSET    W8.0
02BA:  NEG     W4,W4
02BC:  COM     W5,W5
02BE:  COM     W6,W6
02C0:  COM     W7,W7
02C2:  IOR      W4,  W5,W9
02C4:  BRA     NZ,2CA
02C6:  IOR      W6,  W7,W9
02C8:  BRA     Z,2F4
02CA:  MOV     #473,W9
02CC:  BTSC    W3.4
02CE:  BRA     2E6
02D0:  BCLR.B  42.0
02D2:  RLC     W4,W4
02D4:  RLC     W5,W5
02D6:  RLC     W6,W6
02D8:  RLC     W7,W7
02DA:  RLC     W0,W0
02DC:  RLC     W1,W1
02DE:  RLC     W2,W2
02E0:  RLC     W3,W3
02E2:  DEC     W9,W9
02E4:  BRA     NZ,2CC
02E6:  SL      W9,#4,W9
02E8:  BCLR.B  42.0
02EA:  BCLR    W9.F
02EC:  BCLR    W3.4
02EE:  XOR     W9,W3,W3
02F0:  BTSC    W8.0
02F2:  BSET    W3.F
02F4:  MOV     #12,W5
02F6:  REPEAT  #3
02F8:  MOV     [--W15],[W5--]
02FA:  MOV     [--W15],W5
02FC:  RETURN  
02FE:  MOV     W8,[W15++]
0300:  MOV     #12,W8
0302:  REPEAT  #4
0304:  MOV     [W8++],[W15++]
0306:  CLR     W11
0308:  MUL.UU  W12,#0,W12
030A:  MOV     W3,W8
030C:  MOV     W7,W9
030E:  MOV     #7FF,W10
0310:  BCLR.B  42.0
0312:  BCLR.B  42.1
0314:  ASR     W8,#4,W8
0316:  AND     W10,W8,W8
0318:  CP0     W8
031A:  BRA     Z,3FE
031C:  BCLR.B  42.0
031E:  BCLR.B  42.1
0320:  ASR     W9,#4,W9
0322:  AND     W10,W9,W9
0324:  CP0     W9
0326:  BRA     Z,3FE
0328:  ADD     W9,W8,W8
032A:  BTSC    W9.B
032C:  BRA     336
032E:  SUB     #3FF,W8
0330:  BRA     Z,3FE
0332:  BRA     NC,3FE
0334:  BRA     33C
0336:  MOV     #401,W10
0338:  ADD.B   W10L,W5L,W5L
033A:  BRA     C,3FE
033C:  XOR     W3,W7,W13
033E:  BCLR.B  42.0
0340:  BCLR.B  42.1
0342:  AND     #F,W3
0344:  BSET    W3.4
0346:  AND     #F,W7
0348:  BSET    W7.4
034A:  MOV     W8,[W15++]
034C:  MUL.UU  W4,W1,W8
034E:  MUL.UU  W5,W0,W10
0350:  ADD     W8,W10,W10
0352:  ADDC    W9,W11,W11
0354:  ADDC    #0,W12
0356:  MUL.UU  W4,W2,W8
0358:  ADD     W8,W11,W11
035A:  ADDC    W9,W12,W12
035C:  MUL.UU  W5,W1,W8
035E:  CLR     W10
0360:  ADD     W8,W11,W11
0362:  ADDC    W9,W12,W12
0364:  ADDC    #0,W10
0366:  MUL.UU  W6,W0,W8
0368:  ADD     W8,W11,W11
036A:  ADDC    W9,W12,W12
036C:  ADDC    #0,W10
036E:  CLR     W11
0370:  MUL.UU  W4,W3,W8
0372:  ADD     W8,W12,W12
0374:  ADDC    W9,W10,W10
0376:  ADDC    #0,W11
0378:  MUL.UU  W5,W2,W8
037A:  ADD     W8,W12,W12
037C:  ADDC    W9,W10,W10
037E:  ADDC    #0,W11
0380:  MUL.UU  W6,W1,W8
0382:  ADD     W8,W12,W12
0384:  ADDC    W9,W10,W10
0386:  ADDC    #0,W11
0388:  MUL.UU  W7,W0,W8
038A:  ADD     W8,W12,W12
038C:  ADDC    W9,W10,W10
038E:  ADDC    #0,W11
0390:  MOV     W12,W0
0392:  CLR     W12
0394:  MUL.UU  W5,W3,W8
0396:  ADD     W8,W10,W10
0398:  ADDC    W9,W11,W11
039A:  ADDC    #0,W12
039C:  MUL.UU  W6,W2,W8
039E:  ADD     W8,W10,W10
03A0:  ADDC    W9,W11,W11
03A2:  ADDC    #0,W12
03A4:  MUL.UU  W6,W3,W8
03A6:  ADD     W8,W11,W11
03A8:  ADDC    W9,W12,W12
03AA:  MUL.UU  W7,W1,W8
03AC:  ADD     W8,W10,W10
03AE:  ADDC    W9,W11,W11
03B0:  ADDC    #0,W12
03B2:  MUL.UU  W7,W2,W8
03B4:  ADD     W8,W11,W11
03B6:  ADDC    W9,W12,W12
03B8:  MUL.UU  W7,W3,W8
03BA:  ADD     W8,W12,W12
03BC:  MOV     W10,W1
03BE:  MOV     W11,W2
03C0:  MOV     W12,W3
03C2:  MOV     #5,W4
03C4:  BCLR.B  42.0
03C6:  RRC     W3,W3
03C8:  RRC     W2,W2
03CA:  RRC     W1,W1
03CC:  RRC     W0,W0
03CE:  DEC     W4,W4
03D0:  BRA     NZ,3C4
03D2:  MOV     [--W15],W8
03D4:  INC     W8,W8
03D6:  IOR      W0,  W1,W6
03D8:  BRA     Z,3DC
03DA:  BRA     3E0
03DC:  IOR      W2,  W3,W6
03DE:  BRA     Z,3F0
03E0:  BTSC    W3.4
03E2:  BRA     3F0
03E4:  BCLR.B  42.0
03E6:  RLC     W0,W0
03E8:  RLC     W1,W1
03EA:  RLC     W2,W2
03EC:  RLC     W3,W3
03EE:  DEC     W8,W8
03F0:  SL      W8,#4,W8
03F2:  BCLR    W3.F
03F4:  BTSC    W13.F
03F6:  BSET    W3.F
03F8:  BCLR    W3.4
03FA:  XOR     W8,W3,W3
03FC:  BRA     404
03FE:  MUL.UU  W0,#0,W0
0400:  MUL.UU  W0,#0,W2
0402:  BRA     404
0404:  MOV     #1A,W8
0406:  REPEAT  #4
0408:  MOV     [--W15],[W8--]
040A:  MOV     [--W15],W8
040C:  RETURN  
040E:  MOV     W8,[W15++]
0410:  MOV     #12,W8
0412:  REPEAT  #4
0414:  MOV     [W8++],[W15++]
0416:  XOR     W3,W7,W13
0418:  MOV     W3,W8
041A:  MOV     W7,W9
041C:  MOV     #7FF,W10
041E:  BCLR.B  42.0
0420:  BCLR.B  42.1
0422:  ASR     W8,#4,W8
0424:  AND     W10,W8,W8
0426:  CP0     W8
0428:  BRA     Z,502
042A:  BCLR.B  42.0
042C:  BCLR.B  42.1
042E:  ASR     W9,#4,W9
0430:  AND     W10,W9,W9
0432:  CP0     W9
0434:  BRA     Z,502
0436:  CLR     W10
0438:  SUB     W8,W9,W12
043A:  BRA     NC,442
043C:  ADD     #3FF,W12
043E:  BRA     C,502
0440:  BRA     44A
0442:  MOV     #401,W11
0444:  SUB     W12,W11,W12
0446:  BRA     NC,502
0448:  BRA     Z,502
044A:  CLR     W8
044C:  CLR     W9
044E:  CLR     W10
0450:  CLR     W11
0452:  AND     #1F,W3
0454:  BSET    W3.4
0456:  AND     #1F,W7
0458:  BSET    W7.4
045A:  MOV     W12,[W15++]
045C:  MOV     #36,W12
045E:  SUB     W0,W4,W0
0460:  SUBB    W1,W5,W1
0462:  SUBB    W2,W6,W2
0464:  SUBB    W3,W7,W3
0466:  BRA     N,46C
0468:  BRA     C,476
046A:  BRA     NZ,478
046C:  ADD     W0,W4,W0
046E:  ADDC    W1,W5,W1
0470:  ADDC    W2,W6,W2
0472:  ADDC    W3,W7,W3
0474:  BRA     478
0476:  BSET    W8.0
0478:  DEC     W12,W12
047A:  BRA     Z,492
047C:  BCLR.B  42.0
047E:  RLC     W0,W0
0480:  RLC     W1,W1
0482:  RLC     W2,W2
0484:  RLC     W3,W3
0486:  BCLR.B  42.0
0488:  RLC     W8,W8
048A:  RLC     W9,W9
048C:  RLC     W10,W10
048E:  RLC     W11,W11
0490:  BRA     45E
0492:  MOV     [--W15],W12
0494:  BTSC    W11.5
0496:  BRA     49A
0498:  BRA     4A6
049A:  BCLR.B  42.0
049C:  RRC     W11,W11
049E:  RRC     W10,W10
04A0:  RRC     W9,W9
04A2:  RRC     W8,W8
04A4:  BRA     4AC
04A6:  DEC     W12,W12
04A8:  BCLR.B  42.0
04AA:  BRA     Z,502
04AC:  BTSC.B  42.0
04AE:  BRA     4C2
04B0:  RLC     W0,W0
04B2:  RLC     W1,W1
04B4:  RLC     W2,W2
04B6:  RLC     W3,W3
04B8:  SUB     W0,W4,W4
04BA:  SUBB    W1,W5,W5
04BC:  SUBB    W2,W6,W6
04BE:  SUBB    W3,W7,W7
04C0:  BRA     NC,4EC
04C2:  INC     W8,W8
04C4:  BRA     NZ,4EC
04C6:  INC     W9,W9
04C8:  BRA     NZ,4EC
04CA:  INC     W10,W10
04CC:  BRA     NZ,4EC
04CE:  INC     W11,W11
04D0:  BRA     NZ,4EC
04D2:  INC     W12,W12
04D4:  BRA     Z,502
04D6:  BRA     4EC
04D8:  DEC     W12,W12
04DA:  BRA     Z,502
04DC:  BTSC    W11.4
04DE:  BRA     4EC
04E0:  BCLR.B  42.0
04E2:  RLC     W8,W8
04E4:  RLC     W9,W9
04E6:  RLC     W10,W10
04E8:  RLC     W11,W11
04EA:  BRA     4DC
04EC:  SL      W12,#4,W12
04EE:  BCLR.B  42.0
04F0:  BCLR    W12.F
04F2:  BTSC    W13.F
04F4:  BSET    W12.F
04F6:  BCLR    W11.4
04F8:  XOR     W12,W11,W3
04FA:  MOV     W10,W2
04FC:  MOV     W9,W1
04FE:  MOV     W8,W0
0500:  BRA     50C
0502:  MOV     #0,W0
0504:  MOV     #0,W1
0506:  MOV     #0,W2
0508:  MOV     #0,W3
050A:  BRA     50C
050C:  MOV     #1A,W8
050E:  REPEAT  #4
0510:  MOV     [--W15],[W8--]
0512:  MOV     [--W15],W8
0514:  RETURN  
0516:  MOV     W5,[W15++]
0518:  MOV     W6,[W15++]
051A:  MOV     W3,W4
051C:  MOV     W3,W6
051E:  BCLR.B  42.0
0520:  ASR     W4,#4,W4
0522:  MOV     #7FF,W5
0524:  AND     W5,W4,W4
0526:  BRA     NZ,52E
0528:  MUL.UU  W0,#0,W0
052A:  CLR     W2
052C:  BRA     554
052E:  SUB     #380,W4
0530:  AND     #F,W3
0532:  MOV     #3,W7
0534:  BCLR.B  42.0
0536:  RLC     W0,W0
0538:  RLC     W1,W1
053A:  RLC     W2,W2
053C:  RLC     W3,W3
053E:  DEC     W7,W7
0540:  BRA     NZ,534
0542:  MOV     W1,W0
0544:  MOV     W2,W1
0546:  BCLR    W3.7
0548:  SWAP    W4
054A:  BCLR.B  42.0
054C:  RRC     W4,W4
054E:  BTSC    W6.F
0550:  BSET    W4.F
0552:  XOR     W4,W3,W2
0554:  MOV     [--W15],W6
0556:  MOV     [--W15],W5
0558:  RETURN  
055A:  MOV     W5,[W15++]
055C:  MOV     #C,W5
055E:  REPEAT  #3
0560:  MOV     [W5++],[W15++]
0562:  CLR     W9
0564:  MOV     #8000,W8
0566:  BTSC.B  43.0
0568:  XOR     W8,W3,W3
056A:  CP0     W0
056C:  BRA     NZ,574
056E:  MOV     #7FFF,W10
0570:  AND     W1,W10,W10
0572:  BTSS.B  42.1
0574:  MOV     W1,W10
0576:  XOR     W3,W10,W11
0578:  MOV     W1,W6
057A:  MOV     W3,W7
057C:  MOV     W3,W12
057E:  BCLR.B  42.1
0580:  BCLR.B  42.0
0582:  RLC     W6,W6
0584:  SWAP    W6
0586:  AND     #FF,W6
0588:  CP0     W6
058A:  BRA     Z,6CE
058C:  BCLR.B  42.1
058E:  BCLR.B  42.0
0590:  RLC     W7,W7
0592:  SWAP    W7
0594:  AND     #FF,W7
0596:  CP0     W7
0598:  BRA     Z,6D8
059A:  BCLR.B  42.1
059C:  BCLR.B  42.0
059E:  CP      W7,W6
05A0:  BRA     Z,6DA
05A2:  BRA     N,6EA
05A4:  BCLR    W9.0
05A6:  BSET    W9.1
05A8:  SUB     W7,W6,W8
05AA:  MOV     W7,W6
05AC:  AND     #FF,W1
05AE:  BSET    W1.7
05B0:  AND     #FF,W3
05B2:  BSET    W3.7
05B4:  MOV     #28,W7
05B6:  CP      W7,W8
05B8:  BRA     N,5DC
05BA:  BCLR.B  42.1
05BC:  BCLR.B  42.0
05BE:  RRC     W1,W1
05C0:  RRC     W0,W0
05C2:  DEC     W8,W8
05C4:  BRA     NZ,5BA
05C6:  BRA     5E2
05C8:  MOV     #28,W7
05CA:  CP      W7,W8
05CC:  BRA     N,5E0
05CE:  BCLR.B  42.1
05D0:  BCLR.B  42.0
05D2:  RRC     W3,W3
05D4:  RRC     W2,W2
05D6:  DEC     W8,W8
05D8:  BRA     NZ,5CE
05DA:  BRA     5FA
05DC:  MOV     W2,W0
05DE:  MOV     W3,W1
05E0:  BRA     668
05E2:  BTSS    W11.F
05E4:  BRA     608
05E6:  BTSC    W9.4
05E8:  MOV     W12,W11
05EA:  NEG     W0,W0
05EC:  BRA     Z,5F2
05EE:  COM.B   W1L,W1L
05F0:  BRA     5F4
05F2:  NEG     W1,W1
05F4:  BTSC    W9.4
05F6:  BRA     64E
05F8:  BRA     608
05FA:  BTSS    W11.F
05FC:  BRA     608
05FE:  NEG     W2,W2
0600:  BRA     Z,606
0602:  COM.B   W3L,W3L
0604:  BRA     608
0606:  NEG     W3,W3
0608:  AND     #FF,W5
060A:  BCLR.B  42.1
060C:  BCLR.B  42.0
060E:  ADD     W0,W2,W0
0610:  ADDC.B  W1L,W3L,W1L
0612:  BTSC.B  42.0
0614:  BSET    W9.3
0616:  BTSC    W9.0
0618:  BRA     62C
061A:  BTSC    W9.1
061C:  BRA     620
061E:  BRA     636
0620:  BTSC    W11.F
0622:  BRA     64E
0624:  BTSC    W9.3
0626:  BRA     67A
0628:  BSET    W9.6
062A:  BRA     668
062C:  BTSC    W11.F
062E:  BRA     64E
0630:  BTSC    W9.3
0632:  BRA     67A
0634:  BRA     668
0636:  BCLR    W9.2
0638:  BTSC    W11.F
063A:  BRA     644
063C:  MOV     W10,W11
063E:  BTSC    W9.3
0640:  BRA     67A
0642:  BRA     6B0
0644:  BSET    W9.4
0646:  XOR.B   #80,W1L
0648:  BTSC    W1.7
064A:  BRA     5E6
064C:  MOV     W10,W11
064E:  AND     #FF,W1
0650:  IOR      W0,  W1,W7
0652:  BRA     Z,668
0654:  BTSC    W1.7
0656:  BRA     668
0658:  BCLR.B  42.1
065A:  BCLR.B  42.0
065C:  RLC     W0,W0
065E:  RLC     W1,W1
0660:  DEC     W6,W6
0662:  BTSC.B  42.1
0664:  BRA     6C8
0666:  BRA     654
0668:  BTSC    W9.0
066A:  MOV     W10,W11
066C:  BTSC    W9.1
066E:  MOV     W12,W11
0670:  BTSS    W9.5
0672:  BRA     6A8
0674:  BTSC    W10.F
0676:  BSET    W0.8
0678:  BRA     6B0
067A:  BSET.B  42.0
067C:  RRC.B   W1L,W1L
067E:  RRC     W0,W0
0680:  BTSC.B  42.0
0682:  BSET    W9.5
0684:  INC     W6,W6
0686:  BRA     Z,6C8
0688:  BTSS    W9.5
068A:  BRA     69C
068C:  INC     W0,W0
068E:  BRA     NZ,69C
0690:  INC.B   W1L,W1L
0692:  BRA     NZ,69C
0694:  RRC.B   W1L,W1L
0696:  RRC     W0,W0
0698:  INC     W6,W6
069A:  BRA     Z,6C8
069C:  BTSC    W9.0
069E:  MOV     W10,W11
06A0:  BTSC    W9.1
06A2:  MOV     W12,W11
06A4:  BTSC.B  42.1
06A6:  BRA     6C8
06A8:  BTSC    W9.6
06AA:  MOV     W10,W11
06AC:  BTSC    W9.7
06AE:  MOV     W12,W11
06B0:  IOR      W0,  W1,W2
06B2:  BRA     Z,6FA
06B4:  BCLR    W1.7
06B6:  SWAP    W6
06B8:  BCLR.B  42.1
06BA:  BCLR.B  42.0
06BC:  RRC     W6,W6
06BE:  XOR     W6,W1,W1
06C0:  BSET    W1.F
06C2:  BTSS    W11.F
06C4:  BCLR    W1.F
06C6:  BRA     6FA
06C8:  MOV     #0,W0
06CA:  MOV     #0,W1
06CC:  BRA     6FA
06CE:  BTSC    W10.F
06D0:  XOR     W8,W3,W3
06D2:  MOV     W2,W0
06D4:  MOV     W3,W1
06D6:  BRA     6FA
06D8:  BRA     6FA
06DA:  AND     #FF,W3
06DC:  BSET    W3.7
06DE:  AND     #FF,W1
06E0:  BSET    W1.7
06E2:  BTSC    W11.F
06E4:  BCLR    W3.7
06E6:  BSET    W9.2
06E8:  BRA     5FA
06EA:  SUB     W6,W7,W8
06EC:  AND     #FF,W1
06EE:  BSET    W1.7
06F0:  AND     #FF,W3
06F2:  BSET    W3.7
06F4:  BCLR    W9.1
06F6:  BSET    W9.0
06F8:  BRA     5C8
06FA:  MOV     #12,W5
06FC:  REPEAT  #3
06FE:  MOV     [--W15],[W5--]
0700:  MOV     [--W15],W5
0702:  RETURN  
0704:  MOV     W5,[W15++]
0706:  MOV     #C,W5
0708:  REPEAT  #4
070A:  MOV     [W5++],[W15++]
070C:  MOV     W0,W4
070E:  MOV     W1,W5
0710:  MOV     W3,W7
0712:  MOV     W2,W6
0714:  BCLR.B  42.0
0716:  BCLR.B  42.1
0718:  RLC     W1,W1
071A:  SWAP    W1
071C:  AND     #FF,W1
071E:  CP0     W1
0720:  BRA     Z,7B8
0722:  BCLR.B  42.0
0724:  BCLR.B  42.1
0726:  RLC     W3,W3
0728:  SWAP    W3
072A:  AND     #FF,W3
072C:  CP0     W3
072E:  BRA     Z,7B8
0730:  ZE      W0,W0
0732:  ADD.B   W3L,W1L,W0L
0734:  BRA     C,73E
0736:  SUB     #7F,W0
0738:  BRA     Z,7B8
073A:  BRA     NC,7B8
073C:  BRA     742
073E:  ADD.B   #81,W0L
0740:  BRA     C,7B8
0742:  XOR     W5,W7,W10
0744:  BCLR.B  42.0
0746:  BCLR.B  42.1
0748:  AND     #FF,W5
074A:  BSET    W5.7
074C:  BCLR.B  42.0
074E:  AND     #FF,W7
0750:  BSET    W7.7
0752:  MUL.UU  W4,W6,W2
0754:  MUL.UU  W5,W6,W8
0756:  ADDC    W8,W3,W3
0758:  MOV     W9,W1
075A:  BTSC.B  42.0
075C:  INC     W1,W1
075E:  BCLR.B  42.0
0760:  MUL.UU  W7,W4,W8
0762:  ADDC    W8,W3,W3
0764:  ADDC    W9,W1,W1
0766:  MUL.UU  W5,W7,W8
0768:  ADDC    W8,W1,W1
076A:  INC     W0,W0
076C:  CP0     W1
076E:  BTSC.B  42.1
0770:  BRA     774
0772:  BRA     77A
0774:  CP0     W3
0776:  BTSC.B  42.1
0778:  BRA     784
077A:  BTSC    W1.F
077C:  BRA     784
077E:  RLC     W3,W3
0780:  RLC     W1,W1
0782:  DEC     W0,W0
0784:  MOV     W1,W2
0786:  BCLR.B  42.0
0788:  BTSS    W3.7
078A:  BRA     79E
078C:  MOV     #FF00,W7
078E:  AND     W3,W7,W3
0790:  ADD     #100,W3
0792:  ADDC    W2,#0,W2
0794:  CP0     W2
0796:  BRA     NZ,79E
0798:  CP0     W3
079A:  BRA     NZ,79E
079C:  INC     W0,W0
079E:  SWAP    W0
07A0:  BCLR.B  42.0
07A2:  BCLR.B  42.1
07A4:  RRC     W0,W1
07A6:  BTSC    W10.F
07A8:  BSET    W1.F
07AA:  BCLR    W2.F
07AC:  SWAP    W2
07AE:  XOR.B   W2L,W1L,W1L
07B0:  SWAP    W3
07B2:  MOV.B   W3L,W2L
07B4:  MOV     W2,W0
07B6:  BRA     7BE
07B8:  MOV     #0,W0
07BA:  MOV     #0,W1
07BC:  BRA     7BE
07BE:  MOV     #14,W5
07C0:  REPEAT  #4
07C2:  MOV     [--W15],[W5--]
07C4:  MOV     [--W15],W5
07C6:  RETURN  
07C8:  MOV     W5,[W15++]
07CA:  MOV     W6,[W15++]
07CC:  MOV     W7,[W15++]
07CE:  XOR     W1,W3,W4
07D0:  BTSS    W4.F
07D2:  BRA     7E0
07D4:  BCLR.B  42.0
07D6:  BCLR.B  42.1
07D8:  BTSS    W1.F
07DA:  BRA     828
07DC:  BSET.B  42.0
07DE:  BRA     828
07E0:  MOV     W1,W4
07E2:  MOV     W0,W5
07E4:  MOV     W3,W6
07E6:  MOV     W2,W7
07E8:  RLC     W1,W1
07EA:  SWAP    W1
07EC:  RLC     W3,W3
07EE:  SWAP    W3
07F0:  SUB.B   W3L,W1L,W1L
07F2:  BRA     Z,7FE
07F4:  BTSS    W4.F
07F6:  BRA     828
07F8:  MOV     #1,W0
07FA:  XOR.B   42
07FC:  BRA     828
07FE:  MOV.B   W4L,W1L
0800:  MOV.B   W6L,W3L
0802:  BCLR    W1.7
0804:  BCLR    W3.7
0806:  SUB.B   W3L,W1L,W1L
0808:  BRA     Z,814
080A:  BTSS    W4.F
080C:  BRA     828
080E:  MOV     #1,W0
0810:  XOR.B   42
0812:  BRA     828
0814:  SUB     W7,W5,W1
0816:  BRA     Z,822
0818:  BTSS    W4.F
081A:  BRA     828
081C:  MOV     #1,W0
081E:  XOR.B   42
0820:  BRA     828
0822:  BCLR.B  42.0
0824:  BRA     828
0826:  BRA     828
0828:  MOV     [--W15],W7
082A:  MOV     [--W15],W6
082C:  MOV     [--W15],W5
082E:  RETURN  
*
0F36:  MOV     W5,[W15++]
0F38:  MOV     W2,W3
0F3A:  MOV     W2,W5
0F3C:  BCLR.B  42.0
0F3E:  RLC     W3,W3
0F40:  SWAP    W3
0F42:  AND     #FF,W3
0F44:  BRA     NZ,F4C
0F46:  MUL.UU  W0,#0,W0
0F48:  MUL.UU  W2,#0,W2
0F4A:  BRA     F78
0F4C:  ADD     #380,W3
0F4E:  AND     #7F,W2
0F50:  MOV     #3,W6
0F52:  CLR     W4
0F54:  BCLR.B  42.0
0F56:  RRC     W2,W2
0F58:  RRC     W1,W1
0F5A:  RRC     W0,W0
0F5C:  BTSC.B  42.0
0F5E:  INC     W4,W4
0F60:  DEC     W6,W6
0F62:  BRA     NZ,F54
0F64:  BCLR    W2.7
0F66:  SL      W3,#4,W3
0F68:  BCLR    W3.F
0F6A:  BTSC    W5.F
0F6C:  BSET    W3.F
0F6E:  XOR     W2,W3,W3
0F70:  MOV     W1,W2
0F72:  MOV     W0,W1
0F74:  ADD     W4,W1,W1
0F76:  CLR     W0
0F78:  MOV     [--W15],W5
0F7A:  RETURN  
0F7C:  MOV     W5,[W15++]
0F7E:  MOV     #C,W5
0F80:  REPEAT  #7
0F82:  MOV     [W5++],[W15++]
0F84:  MUL.UU  W6,#0,W6
0F86:  MUL.UU  W8,#0,W8
0F88:  MUL.UU  W10,#0,W10
0F8A:  MUL.UU  W12,#0,W12
0F8C:  MOV     #E,W8
0F8E:  MOV     #0,W9
0F90:  LNK     #10
0F92:  MOV     W12,[W14+W8]
0F94:  DEC2    W8,W8
0F96:  BRA     NN,F92
0F98:  BTSS    W3.F
0F9A:  BRA     FA0
0F9C:  BSET    W4.6
0F9E:  DEC.B   0009
0FA0:  MOV     #7FF0,W5
0FA2:  AND     W3,W5,W5
0FA4:  BRA     Z,10E6
0FA6:  AND     W3,#F,W3
0FA8:  BSET    W3.4
0FAA:  LSR     W5,#4,W5
0FAC:  MOV     #3FF,W6
0FAE:  SUB     W5,W6,W5
0FB0:  BRA     NC,1066
0FB2:  CLR     W8
0FB4:  MOV     #4,W6
0FB6:  BCLR.B  42.0
0FB8:  RLC     W0,W0
0FBA:  RLC     W1,W1
0FBC:  RLC     W2,W2
0FBE:  RLC     W3,W3
0FC0:  DEC     W6,W6
0FC2:  BRA     NZ,FB6
0FC4:  CP      W5,#4
0FC6:  BRA     C,FD4
0FC8:  CP      W5,#3
0FCA:  BRA     NZ,10DE
0FCC:  LSR     W3,#5,W6
0FCE:  CP      W6,#A
0FD0:  BTSS.B  42.0
0FD2:  BRA     10DE
0FD4:  MOV     #3,W6
0FD6:  SUB     W5,W6,W5
0FD8:  INC     W8,W8
0FDA:  CALL    127A
0FDE:  CALL    125E
0FE2:  BCLR.B  42.0
0FE4:  RLC     W0,W0
0FE6:  RLC     W1,W1
0FE8:  RLC     W2,W2
0FEA:  RLC     W3,W3
0FEC:  CALL    123A
0FF0:  MOV     #2,W6
0FF2:  BCLR.B  42.0
0FF4:  RRC     W3,W3
0FF6:  RRC     W2,W2
0FF8:  RRC     W1,W1
0FFA:  RRC     W0,W0
0FFC:  DEC     W6,W6
0FFE:  BRA     NZ,FF2
1000:  CALL    125E
1004:  MOV     #4,W6
1006:  BCLR.B  42.0
1008:  RRC     W13,W13
100A:  RRC     W12,W12
100C:  RRC     W11,W11
100E:  RRC     W10,W10
1010:  DEC     W6,W6
1012:  BRA     NZ,1006
1014:  CALL    123A
1018:  CALL    125E
101C:  MOV     #8,W6
101E:  BCLR.B  42.0
1020:  RRC     W13,W13
1022:  RRC     W12,W12
1024:  RRC     W11,W11
1026:  RRC     W10,W10
1028:  DEC     W6,W6
102A:  BRA     NZ,101E
102C:  AND     #FF,W13
102E:  CALL    123A
1032:  CALL    125E
1036:  MOV     W11,W10
1038:  MOV     W12,W11
103A:  MOV     W13,W12
103C:  CLR     W13
103E:  CALL    123A
1042:  CALL    1268
1046:  BTSC    W3.8
1048:  BRA     FC4
104A:  CP0     W5
104C:  BRA     NZ,1058
104E:  INC     W0,W0
1050:  INC     W1,W1
1052:  INC     W2,W2
1054:  INC     W3,W3
1056:  BRA     10DE
1058:  BCLR.B  42.0
105A:  RLC     W0,W0
105C:  RLC     W1,W1
105E:  RLC     W2,W2
1060:  RLC     W3,W3
1062:  DEC     W5,W5
1064:  BRA     FC4
1066:  COM     W5,W5
1068:  INC     W5,W5
106A:  MOV     #3FF,W6
106C:  ADD     W5,W6,W5
106E:  CLR     W8
1070:  MOV     #4,W6
1072:  BCLR.B  42.0
1074:  RLC     W0,W0
1076:  RLC     W1,W1
1078:  RLC     W2,W2
107A:  RLC     W3,W3
107C:  DEC     W6,W6
107E:  BRA     NZ,1072
1080:  ADD     W5,#4,W5
1082:  MOV     #3FF,W6
1084:  SUB     W5,W6,W5
1086:  CP      W5,#5
1088:  BRA     NC,10F0
108A:  CALL    127A
108E:  CALL    125E
1092:  BCLR.B  42.0
1094:  RLC     W0,W0
1096:  RLC     W1,W1
1098:  RLC     W2,W2
109A:  RLC     W3,W3
109C:  BCLR.B  42.0
109E:  RLC     W0,W0
10A0:  RLC     W1,W1
10A2:  RLC     W2,W2
10A4:  RLC     W3,W3
10A6:  CALL    123A
10AA:  CALL    1268
10AE:  BCLR.B  42.0
10B0:  RLC     W0,W0
10B2:  RLC     W1,W1
10B4:  RLC     W2,W2
10B6:  RLC     W3,W3
10B8:  INC     W8,W8
10BA:  MOV     #3,W6
10BC:  BCLR.B  42.0
10BE:  RRC     W3,W3
10C0:  RRC     W2,W2
10C2:  RRC     W1,W1
10C4:  RRC     W0,W0
10C6:  DEC     W6,W6
10C8:  BRA     NZ,10BC
10CA:  SUB     W5,#3,W5
10CC:  BTSS    W3.9
10CE:  BRA     1086
10D0:  BCLR.B  42.0
10D2:  RRC     W3,W3
10D4:  RRC     W2,W2
10D6:  RRC     W1,W1
10D8:  RRC     W0,W0
10DA:  DEC     W5,W5
10DC:  BRA     1086
10DE:  NEG     W5,W5
10E0:  ADD     W5,#3,W5
10E2:  MOV     #2B,W6
10E4:  BRA     10F4
10E6:  MUL.UU  W0,#0,W0
10E8:  MUL.UU  W2,#0,W2
10EA:  CLR     W8
10EC:  CLR     W6
10EE:  BRA     10F4
10F0:  DEC     W5,W5
10F2:  MOV     #2D,W6
10F4:  BTSS    W4.6
10F6:  BRA     110C
10F8:  MOV     W0,W7
10FA:  MOV     W4,[W15++]
10FC:  BTSC.B  223.1
10FE:  BRA     10FC
1100:  MOV     #2D,W4
1102:  MOV     W4,224
1104:  MOV     [--W15],W4
1106:  MOV     W7,W0
1108:  BCLR    W4.6
110A:  BCLR    W4.7
110C:  CLR     W10
110E:  LSR     W3,#5,W9
1110:  CP0     W5
1112:  BRA     Z,111E
1114:  MOV     W5,W11
1116:  BCLR.B  42.0
1118:  RRC     W9,W9
111A:  DEC     W11,W11
111C:  BRA     NZ,1116
111E:  CP.B    W4L,W10L
1120:  BRA     NC,1192
1122:  MOV     W0,W7
1124:  MOV     #30,W0
1126:  ADD     W9,W0,W0
1128:  MOV     W4,[W15++]
112A:  BTSC.B  223.1
112C:  BRA     112A
112E:  MOV     W0,224
1130:  MOV     [--W15],W4
1132:  MOV     W7,W0
1134:  CP0     W10
1136:  BRA     NZ,1148
1138:  MOV     W0,W7
113A:  MOV     W4,[W15++]
113C:  BTSC.B  223.1
113E:  BRA     113C
1140:  MOV     #2E,W4
1142:  MOV     W4,224
1144:  MOV     [--W15],W4
1146:  MOV     W7,W0
1148:  INC     W10,W10
114A:  CP0     W5
114C:  BRA     Z,1158
114E:  MOV     W5,W11
1150:  BCLR.B  42.0
1152:  RLC     W9,W9
1154:  DEC     W11,W11
1156:  BRA     NZ,1150
1158:  LSR     W3,#5,W7
115A:  SUB     W7,W9,W7
115C:  SL      W7,#5,W7
115E:  AND     W3,#1F,W3
1160:  IOR      W7,  W3,W3
1162:  CALL    127A
1166:  CALL    125E
116A:  BCLR.B  42.0
116C:  RLC     W0,W0
116E:  RLC     W1,W1
1170:  RLC     W2,W2
1172:  RLC     W3,W3
1174:  BCLR.B  42.0
1176:  RLC     W0,W0
1178:  RLC     W1,W1
117A:  RLC     W2,W2
117C:  RLC     W3,W3
117E:  CALL    123A
1182:  CALL    1268
1186:  BCLR.B  42.0
1188:  RLC     W0,W0
118A:  RLC     W1,W1
118C:  RLC     W2,W2
118E:  RLC     W3,W3
1190:  BRA     110E
1192:  MOV     W0,W7
1194:  MOV     W4,[W15++]
1196:  BTSC.B  223.1
1198:  BRA     1196
119A:  MOV     #45,W4
119C:  MOV     W4,224
119E:  MOV     [--W15],W4
11A0:  MOV     W7,W0
11A2:  CP0     W6
11A4:  BRA     Z,11B4
11A6:  MOV     W0,W7
11A8:  MOV     W6,W0
11AA:  MOV     W4,[W15++]
11AC:  BTSC.B  223.1
11AE:  BRA     11AC
11B0:  MOV     W0,224
11B2:  MOV     [--W15],W4
11B4:  CLR     W12
11B6:  MOV     W8,W13
11B8:  SUB     W13,#A,W13
11BA:  BRA     NC,121C
11BC:  INC     W12,W12
11BE:  SUB     W13,#A,W13
11C0:  BRA     C,11BC
11C2:  ADD     W13,#A,W13
11C4:  CP      W12,#A
11C6:  BRA     C,11E6
11C8:  MOV     W0,W7
11CA:  MOV     #30,W0
11CC:  ADD.B   W0L,W12L,W0L
11CE:  MOV     W4,[W15++]
11D0:  BTSC.B  223.1
11D2:  BRA     11D0
11D4:  MOV     W0,224
11D6:  MOV     #30,W0
11D8:  ADD.B   W0L,W13L,W0L
11DA:  BTSC.B  223.1
11DC:  BRA     11DA
11DE:  MOV     W0,224
11E0:  MOV     [--W15],W4
11E2:  MOV     W7,W0
11E4:  BRA     128C
11E6:  CLR     W11
11E8:  SUB     W12,#A,W12
11EA:  INC     W11,W11
11EC:  SUB.B   W12L,#A,W12L
11EE:  BRA     C,11EA
11F0:  MOV     #30,W0
11F2:  ADD.B   W12L,#A,W12L
11F4:  MOV     W0,W7
11F6:  MOV     #30,W0
11F8:  ADD.B   W0L,W11L,W0L
11FA:  MOV     W4,[W15++]
11FC:  BTSC.B  223.1
11FE:  BRA     11FC
1200:  MOV     W0,224
1202:  MOV     #30,W0
1204:  ADD.B   W0L,W12L,W0L
1206:  BTSC.B  223.1
1208:  BRA     1206
120A:  MOV     W0,224
120C:  MOV     #30,W0
120E:  ADD.B   W0L,W13L,W0L
1210:  BTSC.B  223.1
1212:  BRA     1210
1214:  MOV     W0,224
1216:  MOV     [--W15],W4
1218:  MOV     W7,W0
121A:  BRA     128C
121C:  ADD.B   W13L,#A,W13L
121E:  MOV     W0,W7
1220:  MOV     W4,[W15++]
1222:  BTSC.B  223.1
1224:  BRA     1222
1226:  MOV     #30,W4
1228:  MOV     W4,224
122A:  MOV     #30,W0
122C:  ADD.B   W0L,W13L,W0L
122E:  BTSC.B  223.1
1230:  BRA     122E
1232:  MOV     W0,224
1234:  MOV     [--W15],W4
1236:  MOV     W7,W0
1238:  BRA     128C
123A:  ADD     W10,W0,W0
123C:  BRA     NC,124A
123E:  INC     W1,W1
1240:  BRA     NZ,124A
1242:  INC     W2,W2
1244:  BRA     NZ,124A
1246:  INC     W3,W3
1248:  BRA     NZ,124A
124A:  ADD     W11,W1,W1
124C:  BRA     NC,1254
124E:  INC     W2,W2
1250:  BRA     NZ,1254
1252:  INC     W3,W3
1254:  ADD     W12,W2,W2
1256:  BTSC.B  42.0
1258:  INC     W3,W3
125A:  ADD     W3,W13,W3
125C:  RETURN  
125E:  MOV     W3,W13
1260:  MOV     W2,W12
1262:  MOV     W1,W11
1264:  MOV     W0,W10
1266:  RETURN  
1268:  MOV     W10,[W14+#8]
126A:  MOV     W11,[W14+#A]
126C:  MOV     W12,[W14+#C]
126E:  MOV     W13,[W14+#E]
1270:  MOV     [W14],W10
1272:  MOV     [W14+#2],W11
1274:  MOV     [W14+#4],W12
1276:  MOV     [W14+#6],W13
1278:  RETURN  
127A:  MOV     W10,[W14]
127C:  MOV     W11,[W14+#2]
127E:  MOV     W12,[W14+#4]
1280:  MOV     W13,[W14+#6]
1282:  MOV     [W14+#8],W10
1284:  MOV     [W14+#A],W11
1286:  MOV     [W14+#C],W12
1288:  MOV     [W14+#E],W13
128A:  RETURN  
128C:  ULNK    
128E:  MOV     #1A,W5
1290:  REPEAT  #7
1292:  MOV     [--W15],[W5--]
1294:  MOV     [--W15],W5
1296:  RETURN  
1298:  MOV     W5,[W15++]
129A:  MOV     #C,W5
129C:  REPEAT  #3
129E:  MOV     [W5++],[W15++]
12A0:  BTSS    W0.F
12A2:  BRA     12BC
12A4:  NEG     W0,W0
12A6:  BSET    W4.8
12A8:  BTSS    W4.F
12AA:  BRA     12BC
12AC:  MOV     W0,[W15++]
12AE:  MOV     #2D,W0
12B0:  BTSC.B  223.1
12B2:  BRA     12B0
12B4:  MOV     W0,224
12B6:  MOV     [--W15],W0
12B8:  BCLR    W4.8
12BA:  DEC.B   0008
12BC:  CLR     W5
12BE:  MOV     W0,W7
12C0:  MOV     W4,W9
12C2:  BCLR    W4.F
12C4:  CP0.B   W4L
12C6:  BRA     NZ,12D4
12C8:  BTSC    W9.F
12CA:  BRA     12D0
12CC:  MOV     #0,W5
12CE:  BRA     12EE
12D0:  MOV     #0,W5
12D2:  BRA     12EE
12D4:  SUB.B   W4L,#6,W5L
12D6:  BRA     NC,12EC
12D8:  MOV     #30,W0
12DA:  BTSS    W9.F
12DC:  MOV     #20,W0
12DE:  BTSC.B  223.1
12E0:  BRA     12DE
12E2:  MOV     W0,224
12E4:  DEC     W5,W5
12E6:  BRA     NN,12DE
12E8:  MOV     #5,W5
12EA:  BRA     12EE
12EC:  MOV     W4,W5
12EE:  MOV     #6,W4
12F0:  BTSC    W5.8
12F2:  INC     W4,W4
12F4:  BSET    W5.E
12F6:  BTSC    W9.F
12F8:  BSET    W5.F
12FA:  MOV     #2710,W8
12FC:  REPEAT  #11
12FE:  DIV.U   W7,W8
1300:  CALL    1344
1304:  MOV     W1,W7
1306:  MOV     #3E8,W8
1308:  REPEAT  #11
130A:  DIV.U   W7,W8
130C:  CALL    1344
1310:  MOV     W1,W7
1312:  MOV     #64,W8
1314:  REPEAT  #11
1316:  DIV.U   W7,W8
1318:  CALL    1344
131C:  MOV     W1,W7
131E:  MOV     #A,W8
1320:  REPEAT  #11
1322:  DIV.U   W7,W8
1324:  CALL    1344
1328:  BTSS    W9.8
132A:  BRA     1336
132C:  MOV     #2D,W0
132E:  BTSC.B  223.1
1330:  BRA     132E
1332:  MOV     W0,224
1334:  BCLR    W9.8
1336:  MOV     #30,W0
1338:  ADD.B   W1L,W0L,W0L
133A:  MOV     W0,2A
133C:  BTSC.B  223.1
133E:  BRA     133C
1340:  MOV     W0,224
1342:  BRA     1384
1344:  MOV     #30,W6
1346:  CP0     W0
1348:  BRA     NZ,1366
134A:  BTSS    W5.E
134C:  BRA     137A
134E:  DEC     W4,W4
1350:  CP.B    W4L,W5L
1352:  BRA     Z,1358
1354:  BTSC.B  42.0
1356:  RETURN  
1358:  CP0     W0
135A:  BRA     NZ,1366
135C:  BTSS    W5.E
135E:  BRA     137A
1360:  BTSS    W5.F
1362:  MOV     #20,W6
1364:  BRA     137A
1366:  BCLR    W5.E
1368:  BTSS    W9.8
136A:  BRA     137A
136C:  MOV     W0,W10
136E:  MOV     #2D,W0
1370:  BTSC.B  223.1
1372:  BRA     1370
1374:  MOV     W0,224
1376:  BCLR    W9.8
1378:  MOV     W10,W0
137A:  ADD.B   W6L,W0L,W0L
137C:  BTSC.B  223.1
137E:  BRA     137C
1380:  MOV     W0,224
1382:  RETURN  
1384:  MOV     #12,W5
1386:  REPEAT  #3
1388:  MOV     [--W15],[W5--]
138A:  MOV     [--W15],W5
138C:  RETURN  
....................  
.................... #list 
....................  
.................... #device ADC=10 
.................... #include <PID.h> 
.................... /*  
....................  * File:   PID.h 
....................  * Author: Arsapol 
....................  * 
....................  * Created on October 22, 2016, 10:23 PM 
....................  */ 
....................  
.................... #ifndef PID_H 
.................... #define	PID_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
....................     /*typedef struct { 
....................         float error; 
....................  
....................         float integral; 
....................         float derivative; 
....................  
....................         float previous_error; 
....................  
....................         float distance_set; 
....................         float current_distance; 
....................  
....................         float output; 
....................  
....................         float KP; 
....................         float KI; 
....................         float KD; 
....................     } PID; 
....................  
....................     float PID_Calc(PID *pid) { 
....................         pid->error = pid->distance_set - pid->current_distance; 
....................         //PID control 
....................         pid->integral += pid->error; 
....................         pid->derivative = pid->error - pid->previous_error; 
....................  
....................         pid->output = (pid->KP * pid->error) + (pid->KI * pid->integral) + (pid->KD * pid->derivative); 
....................  
....................         pid->previous_error = pid->error; 
....................  
....................         return pid->output; 
....................     }*/ 
....................  
.................... #define PI 3.14159265359 
.................... #define CPR 400.0 
.................... #define Diameter 0.8 //unit centimeter - ****************Need 
.................... #define Position_Per_Pulse (2.0*PI*(Diameter/2.0))/CPR //cm 
.................... #define Speed PI*Diameter/CPR 
....................  
.................... #define MAX_SPD 180 //cm/s - ***************************Need Test 
.................... #define MAX_CPR MAX_SPD 
....................  
....................     //New 
....................  
....................     typedef struct { 
....................         float dState; // Last position input 
....................         float iState; // Integrator state 
....................         float iMax, iMin; // Maximum and minimum allowable integrator state 
....................         float iGain, // integral gain 
....................         pGain, // proportional gain 
....................         dGain; // derivative gain 
....................     } SPID; 
....................      
....................     void PID_Init(SPID *pid, float Kp, float Ki, float Kd){ 
*
0B92:  MOV     W5,[W15++]
....................         pid->dState = 0; // Last position input 
0B94:  MOV     #0,W0
0B96:  ADD     88A,W0
0B98:  MOV     W0,W5
0B9A:  CLR.B   [W5]
0B9C:  MOV.B   #0,W0L
0B9E:  MOV.B   W0L,[W5+#1]
0BA0:  MOV.B   #0,W0L
0BA2:  MOV.B   W0L,[W5+#2]
0BA4:  MOV.B   #0,W0L
0BA6:  MOV.B   W0L,[W5+#3]
....................         pid->iState = 0; // Integrator state 
0BA8:  MOV     #4,W0
0BAA:  ADD     88A,W0
0BAC:  MOV     W0,W5
0BAE:  CLR.B   [W5]
0BB0:  MOV.B   #0,W0L
0BB2:  MOV.B   W0L,[W5+#1]
0BB4:  MOV.B   #0,W0L
0BB6:  MOV.B   W0L,[W5+#2]
0BB8:  MOV.B   #0,W0L
0BBA:  MOV.B   W0L,[W5+#3]
....................         pid->iMax = 0; 
0BBC:  MOV     #8,W0
0BBE:  ADD     88A,W0
0BC0:  MOV     W0,W5
0BC2:  CLR.B   [W5]
0BC4:  MOV.B   #0,W0L
0BC6:  MOV.B   W0L,[W5+#1]
0BC8:  MOV.B   #0,W0L
0BCA:  MOV.B   W0L,[W5+#2]
0BCC:  MOV.B   #0,W0L
0BCE:  MOV.B   W0L,[W5+#3]
....................         pid->iMin = 0; // Maximum and minimum allowable integrator state 
0BD0:  MOV     #C,W0
0BD2:  ADD     88A,W0
0BD4:  MOV     W0,W5
0BD6:  CLR.B   [W5]
0BD8:  MOV.B   #0,W0L
0BDA:  MOV.B   W0L,[W5+#1]
0BDC:  MOV.B   #0,W0L
0BDE:  MOV.B   W0L,[W5+#2]
0BE0:  MOV.B   #0,W0L
0BE2:  MOV.B   W0L,[W5+#3]
....................         pid->iGain = Ki; // integral gain 
0BE4:  MOV     #10,W0
0BE6:  ADD     88A,W0
0BE8:  MOV     W0,W5
0BEA:  MOV     #890,W4
0BEC:  MOV     [W4++],[W5++]
0BEE:  MOV     [W4++],[W5++]
....................         pid->pGain = Kp; // proportional gain 
0BF0:  MOV     #14,W0
0BF2:  ADD     88A,W0
0BF4:  MOV     W0,W5
0BF6:  MOV     #88C,W4
0BF8:  MOV     [W4++],[W5++]
0BFA:  MOV     [W4++],[W5++]
....................         pid->dGain = Kd; // derivative gain 
0BFC:  MOV     #18,W0
0BFE:  ADD     88A,W0
0C00:  MOV     W0,W5
0C02:  MOV     #894,W4
0C04:  MOV     [W4++],[W5++]
0C06:  MOV     [W4++],[W5++]
0C08:  MOV     [--W15],W5
0C0A:  RETURN  
....................     } 
....................  
....................     float UpdatePID(SPID * pid, float error, float position) { 
*
0830:  MOV     W5,[W15++]
0832:  MOV     W6,[W15++]
....................         float pTerm, dTerm, iTerm; 
....................         pTerm = pid->pGain * error; 
0834:  MOV     #14,W0
0836:  ADD     8D2,W0
0838:  MOV     #A,W4
083A:  MOV     [W0++],[W4++]
083C:  MOV     [W0++],[W4++]
083E:  MOV     W5,W0
0840:  MOV     W6,W1
0842:  MOV     8D4,W2
0844:  MOV     8D6,W3
0846:  CALL    704
084A:  MOV     W0,8DC
084C:  MOV     W1,8DE
....................         // calculate the proportional term 
....................         // calculate the integral state with appropriate limiting 
....................         pid->iState += error; 
084E:  MOV     #4,W0
0850:  ADD     8D2,W0
0852:  MOV     W0,W5
0854:  BCLR.B  43.0
0856:  MOV     [W5],W0
0858:  MOV     [++W5],W1
085A:  MOV     8D4,W2
085C:  MOV     8D6,W3
085E:  CALL    55A
0862:  MOV     #0,W4
0864:  MOV     [W4++],[W5++]
0866:  MOV     [W4++],[W5++]
....................         if (pid->iState > pid->iMax) pid->iState = pid->iMax; 
0868:  MOV     #4,W0
086A:  ADD     8D2,W0
086C:  MOV     #A,W4
086E:  MOV     [W0++],[W4++]
0870:  MOV     [W0++],[W4++]
0872:  MOV     #8,W0
0874:  ADD     8D2,W0
0876:  MOV     W0,W4
0878:  MOV     #0,W3
087A:  MOV     [W4++],[W3++]
087C:  MOV     [W4++],[W3++]
087E:  MOV     W5,W2
0880:  MOV     W6,W3
0882:  CALL    7C8
0886:  BRA     NC,898
0888:  MOV     #4,W0
088A:  ADD     8D2,W0
088C:  MOV     W0,W5
088E:  MOV     #8,W0
0890:  ADD     8D2,W0
0892:  MOV     [W0++],[W5++]
0894:  MOV     [W0++],[W5++]
0896:  BRA     8CA
....................         else if (pid->iState < pid->iMin) pid->iState = pid->iMin; 
0898:  MOV     #4,W0
089A:  ADD     8D2,W0
089C:  MOV     #A,W4
089E:  MOV     [W0++],[W4++]
08A0:  MOV     [W0++],[W4++]
08A2:  MOV     #C,W0
08A4:  ADD     8D2,W0
08A6:  MOV     W0,W4
08A8:  MOV     #0,W3
08AA:  MOV     [W4++],[W3++]
08AC:  MOV     [W4++],[W3++]
08AE:  MOV     W0,W2
08B0:  MOV     W1,W3
08B2:  MOV     W5,W0
08B4:  MOV     W6,W1
08B6:  CALL    7C8
08BA:  BRA     NC,8CA
08BC:  MOV     #4,W0
08BE:  ADD     8D2,W0
08C0:  MOV     W0,W5
08C2:  MOV     #C,W0
08C4:  ADD     8D2,W0
08C6:  MOV     [W0++],[W5++]
08C8:  MOV     [W0++],[W5++]
....................         iTerm = pid->iGain * pid->iState; // calculate the integral term 
08CA:  MOV     #10,W0
08CC:  ADD     8D2,W0
08CE:  MOV     #A,W4
08D0:  MOV     [W0++],[W4++]
08D2:  MOV     [W0++],[W4++]
08D4:  MOV     #4,W0
08D6:  ADD     8D2,W0
08D8:  MOV     W0,W4
08DA:  MOV     #0,W3
08DC:  MOV     [W4++],[W3++]
08DE:  MOV     [W4++],[W3++]
08E0:  MOV     W0,W2
08E2:  MOV     W1,W3
08E4:  MOV     W5,W0
08E6:  MOV     W6,W1
08E8:  CALL    704
08EC:  MOV     W0,8E4
08EE:  MOV     W1,8E6
....................         dTerm = pid->dGain * (position - pid->dState); 
08F0:  MOV     #18,W0
08F2:  ADD     8D2,W0
08F4:  MOV     #A,W4
08F6:  MOV     [W0++],[W4++]
08F8:  MOV     [W0++],[W4++]
08FA:  MOV     #0,W0
08FC:  ADD     8D2,W0
08FE:  MOV     W0,W4
0900:  MOV     #0,W3
0902:  MOV     [W4++],[W3++]
0904:  MOV     [W4++],[W3++]
0906:  BSET.B  43.0
0908:  MOV     W0,W2
090A:  MOV     W1,W3
090C:  MOV     8D8,W0
090E:  MOV     8DA,W1
0910:  CALL    55A
0914:  MOV     W0,W2
0916:  MOV     W1,W3
0918:  MOV     W5,W0
091A:  MOV     W6,W1
091C:  CALL    704
0920:  MOV     W0,8E0
0922:  MOV     W1,8E2
....................         pid->dState = position; 
0924:  MOV     #0,W0
0926:  ADD     8D2,W0
0928:  MOV     W0,W5
092A:  MOV     #8D8,W4
092C:  MOV     [W4++],[W5++]
092E:  MOV     [W4++],[W5++]
....................         return pTerm + iTerm - dTerm; 
0930:  BCLR.B  43.0
0932:  MOV     8DC,W0
0934:  MOV     8DE,W1
0936:  MOV     8E4,W2
0938:  MOV     8E6,W3
093A:  CALL    55A
093E:  MOV     W0,W5
0940:  MOV     W1,W6
0942:  BSET.B  43.0
0944:  MOV     W5,W0
0946:  MOV     W6,W1
0948:  MOV     8E0,W2
094A:  MOV     8E2,W3
094C:  CALL    55A
0950:  MOV.D   W0,W0
0952:  MOV     [--W15],W6
0954:  MOV     [--W15],W5
0956:  RETURN  
....................     } 
....................  
....................     /*typedef struct { 
....................         boolean usingFeedForward; 
....................         boolean inAuto; 
....................  
....................         //Actual tuning parameters used in PID calculation. 
....................         float Kc_; 
....................         float tauR_; 
....................         float tauD_; 
....................  
....................         //Raw tuning parameters. 
....................         float pParam_; 
....................         float iParam_; 
....................         float dParam_; 
....................  
....................         //The point we want to reach. 
....................         float setPoint_; 
....................         //The thing we measure. 
....................         float processVariable_; 
....................         float prevProcessVariable_; 
....................         //The output that affects the process variable. 
....................         float controllerOutput_; 
....................         float prevControllerOutput_; 
....................  
....................         //We work in % for calculations so these will scale from 
....................         //real world values to 0-100% and back again. 
....................         float inMin_; 
....................         float inMax_; 
....................         float inSpan_; 
....................         float outMin_; 
....................         float outMax_; 
....................         float outSpan_; 
....................  
....................         //The accumulated error, i.e. integral. 
....................         float accError_; 
....................         //The controller output bias. 
....................         float bias_; 
....................  
....................         //The interval between samples. 
....................         float tSample_; 
....................  
....................         //Controller output as a real world value. 
....................         volatile float realOutput_; 
....................     } SPID; 
....................  
....................     void setSetPoint(SPID *pid, float sp) { 
....................         pid->setPoint_ = sp; 
....................     } 
....................  
....................     void setProcessValue(SPID *pid, float pv) { 
....................         pid->processVariable_ = pv; 
....................     } 
....................  
....................     void setInputLimits(SPID *pid, float inMin, float inMax) { 
....................  
....................         //Make sure we haven't been given impossible values. 
....................         if (inMin >= inMax) { 
....................             return; 
....................         } 
....................  
....................         //Rescale the working variables to reflect the changes. 
....................         pid->prevProcessVariable_ *= (inMax - inMin) / pid->inSpan_; 
....................         pid->accError_ *= (inMax - inMin) / pid->inSpan_; 
....................  
....................         //Make sure the working variables are within the new limits. 
....................         if (pid->prevProcessVariable_ > 1) { 
....................             pid->prevProcessVariable_ = 1; 
....................         } else if (pid->prevProcessVariable_ < 0) { 
....................             pid->prevProcessVariable_ = 0; 
....................         } 
....................  
....................         pid->inMin_ = inMin; 
....................         pid->inMax_ = inMax; 
....................         pid->inSpan_ = inMax - inMin; 
....................  
....................     } 
....................  
....................     void setOutputLimits(SPID *pid, float outMin, float outMax) { 
....................  
....................         //Make sure we haven't been given impossible values. 
....................         if (outMin >= outMax) { 
....................             return; 
....................         } 
....................  
....................         //Rescale the working variables to reflect the changes. 
....................         pid->prevControllerOutput_ *= (outMax - outMin) / pid->outSpan_; 
....................  
....................         //Make sure the working variables are within the new limits. 
....................         if (pid->prevControllerOutput_ > 1) { 
....................             pid->prevControllerOutput_ = 1; 
....................         } else if (pid->prevControllerOutput_ < 0) { 
....................             pid->prevControllerOutput_ = 0; 
....................         } 
....................  
....................         pid->outMin_ = outMin; 
....................         pid->outMax_ = outMax; 
....................         pid->outSpan_ = outMax - outMin; 
....................  
....................     } 
....................  
....................     void setTunings(SPID *pid, float Kc, float tauI, float tauD) { 
....................  
....................         //Verify that the tunings make sense. 
....................         if (Kc == 0.0 || tauI < 0.0 || tauD < 0.0) { 
....................             return; 
....................         } 
....................  
....................         //Store raw values to hand back to user on request. 
....................         pid->pParam_ = Kc; 
....................         pid->iParam_ = tauI; 
....................         pid->dParam_ = tauD; 
....................  
....................         float tempTauR; 
....................  
....................         if (tauI == 0.0) { 
....................             tempTauR = 0.0; 
....................         } else { 
....................             tempTauR = (1.0 / tauI) * pid->tSample_; 
....................         } 
....................  
....................         //For "bumpless transfer" we need to rescale the accumulated error. 
....................         if (pid->inAuto) { 
....................             if (tempTauR == 0.0) { 
....................                 pid->accError_ = 0.0; 
....................             } else { 
....................                 pid->accError_ *= (pid->Kc_ * pid->tauR_) / (Kc * tempTauR); 
....................             } 
....................         } 
....................  
....................         pid->Kc_ = Kc; 
....................         pid->tauR_ = tempTauR; 
....................         pid->tauD_ = tauD / pid->tSample_; 
....................  
....................     } 
....................  
....................     void PID_Init(SPID *pid, float Kc, float tauI, float tauD, float interval) { 
....................         pid->usingFeedForward = false; 
....................         pid->inAuto = false; 
....................  
....................         //Default the limits to the full range of I/O: 3.3V 
....................         //Make sure to set these to more appropriate limits for 
....................         //your application. 
....................         setInputLimits(&pid, 0.0, 3.3); 
....................         setOutputLimits(&pid, 0.0, 3.3); 
....................  
....................         pid->tSample_ = interval; 
....................  
....................         setTunings(&pid, Kc, tauI, tauD); 
....................  
....................         pid->setPoint_ = 0.0; 
....................         pid->processVariable_ = 0.0; 
....................         pid->prevProcessVariable_ = 0.0; 
....................         pid->controllerOutput_ = 0.0; 
....................         pid->prevControllerOutput_ = 0.0; 
....................  
....................         pid->accError_ = 0.0; 
....................         pid->bias_ = 0.0; 
....................  
....................         pid->realOutput_ = 0.0; 
....................     } 
....................  
....................     float compute(SPID *pid) { 
....................  
....................         //Pull in the input and setpoint, and scale them into percent span. 
....................         float scaledPV = (pid->processVariable_ - pid->inMin_) / pid->inSpan_; 
....................  
....................         if (scaledPV > 1.0) { 
....................             scaledPV = 1.0; 
....................         } else if (scaledPV < 0.0) { 
....................             scaledPV = 0.0; 
....................         } 
....................  
....................         float scaledSP = (pid->setPoint_ - pid->inMin_) / pid->inSpan_; 
....................         if (scaledSP > 1.0) { 
....................             scaledSP = 1; 
....................         } else if (scaledSP < 0.0) { 
....................             scaledSP = 0; 
....................         } 
....................  
....................         float error = scaledSP - scaledPV; 
....................  
....................         //Check and see if the output is pegged at a limit and only 
....................         //integrate if it is not. This is to prevent reset-windup. 
....................         if (!(pid->prevControllerOutput_ >= 1 && error > 0) && !(pid->prevControllerOutput_ <= 0 && error < 0)) { 
....................             pid->accError_ += error; 
....................         } 
....................  
....................         //Compute the current slope of the input signal. 
....................         float dMeas = (scaledPV - pid->prevProcessVariable_) / pid->tSample_; 
....................  
....................         float scaledBias = 0.0; 
....................  
....................         if (pid->usingFeedForward) { 
....................             scaledBias = (pid->bias_ - pid->outMin_) / pid->outSpan_; 
....................         } 
....................  
....................         //Perform the PID calculation. 
....................         pid->controllerOutput_ = scaledBias + pid->Kc_ * (error + (pid->tauR_ * pid->accError_) - (pid->tauD_ * dMeas)); 
....................  
....................         //Make sure the computed output is within output constraints. 
....................         if (pid->controllerOutput_ < 0.0) { 
....................             pid->controllerOutput_ = 0.0; 
....................         } else if (pid->controllerOutput_ > 1.0) { 
....................             pid->controllerOutput_ = 1.0; 
....................         } 
....................  
....................         //Remember this output for the windup check next time. 
....................         pid->prevControllerOutput_ = pid->controllerOutput_; 
....................         //Remember the input for the derivative calculation next time. 
....................         pid->prevProcessVariable_ = scaledPV; 
....................  
....................         //Scale the output from percent span back out to a real world number. 
....................         return ((pid->controllerOutput_ * pid->outSpan_) + pid->outMin_); 
....................  
....................     }*/ 
....................      
....................     //In main 
....................     /*if (sec_flag == TRUE) { 
....................             sec_flag = FALSE; 
....................             seconds++; 
....................             //printf("%d\r\n", seconds); 
....................         } 
....................           now = seconds; 
....................  
....................         if (now - prev >= RATE * 1000) { 
....................             leftPulses = En_x.Pulses * Speed; 
....................             leftVelocity = (leftPulses - leftPrevPulses) / RATE; 
....................             leftPrevPulses = leftPulses; 
....................             setProcessValue(&Motor_X, leftVelocity); 
....................             leftPwmDuty += compute(&Motor_X); 
....................  
....................             if (leftPwmDuty > 1.0) { 
....................                 leftPwmDuty = 1.0; 
....................             } else if (leftPwmDuty < -1.0) { 
....................                 leftPwmDuty = -1.0; 
....................             } 
....................  
....................             //leftMotor = leftPwmDuty; 
....................  
....................             rightPulses = En_y.Pulses * Speed; 
....................             rightVelocity = (rightPulses - rightPrevPulses) / RATE; 
....................             rightPrevPulses = rightPulses; 
....................             setProcessValue(&Motor_Y, rightVelocity); 
....................             rightPwmDuty += compute(&Motor_Y); 
....................  
....................             if (rightPwmDuty > 1.0) { 
....................                 rightPwmDuty = 1.0; 
....................             } else if (rightPwmDuty < -1.0) { 
....................                 rightPwmDuty = -1.0; 
....................             } 
....................  
....................             //rightMotor = rightPwmDuty; 
.................... #ifdef DEBUG 
....................             printf("left,right pulse duty : %f,%f\n", leftPulses, rightPulses); 
....................             //printf("left,right pwm duty : %f,%f\n",leftPwmDuty,rightPwmDuty); 
....................             printf("left,right Velocity : %f,%f\n", leftVelocity, rightVelocity); 
.................... #endif 
....................             if (leftPwmDuty > 0.1) { 
....................                 output_high(MOTOR_X_DIR); //leftDirection = 1; 
....................                 //leftBrake = 0; 
....................                 Control_Motor(DRIVE_MOTOR_X, leftPwmDuty); //leftMotor = leftPwmDuty; 
....................             } else if (leftPwmDuty < -0.1) { 
....................                 output_low(MOTOR_X_DIR); //leftDirection = 0; 
....................                 //leftBrake = 1; 
....................                 Control_Motor(DRIVE_MOTOR_X, (-1) * leftPwmDuty); //leftMotor = (-1) * leftPwmDuty; 
....................             } else { 
....................                 output_low(MOTOR_X_DIR); //leftDirection = 0; 
....................                 //leftBrake = 0; 
....................                 Control_Motor(DRIVE_MOTOR_X, 0); //leftMotor = 0.0; 
....................             } 
....................  
....................             if (rightPwmDuty > 0.1) { 
....................                 output_high(MOTOR_Y_DIR); //rightDirection = 1; 
....................                 //rightBrake = 0; 
....................                 Control_Motor(DRIVE_MOTOR_Y, rightPwmDuty); //rightMotor = rightPwmDuty; 
....................             } else if (rightPwmDuty < -0.1) { 
....................                 output_low(MOTOR_Y_DIR); //rightDirection = 0; 
....................                 //rightBrake = 1; 
....................                 Control_Motor(DRIVE_MOTOR_Y, (-1) * rightPwmDuty); //rightMotor = (-1) * rightPwmDuty; 
....................             } else { 
....................                 output_low(MOTOR_Y_DIR); //rightDirection = 0; 
....................                 //rightBrake = 0; 
....................                 Control_Motor(DRIVE_MOTOR_Y, 0); //rightMotor = 0.0; 
....................             } 
....................  
....................             prev = now; 
....................         }*/ 
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* PID_H */ 
....................  
....................  
.................... #include <Motor.h> 
.................... /*  
....................  * File:   Motor.h 
....................  * Author: Arsapol 
....................  * 
....................  * Created on October 22, 2016, 11:41 PM 
....................  */ 
.................... #ifndef MOTOR_H 
.................... #define	MOTOR_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................      
....................     typedef struct { 
....................         int B_signal; 
....................         int Pulses; 
....................     } Encoder; 
....................      
....................     void Encoder_Init(Encoder *en){ 
*
0B74:  MOV     W5,[W15++]
....................         en->B_signal = 0; 
0B76:  MOV     #0,W0
0B78:  ADD     88A,W0
0B7A:  MOV     W0,W5
0B7C:  CLR.B   [W5]
0B7E:  MOV.B   #0,W0L
0B80:  MOV.B   W0L,[W5+#1]
....................         en->Pulses = 0; 
0B82:  MOV     #2,W0
0B84:  ADD     88A,W0
0B86:  MOV     W0,W5
0B88:  CLR.B   [W5]
0B8A:  MOV.B   #0,W0L
0B8C:  MOV.B   W0L,[W5+#1]
0B8E:  MOV     [--W15],W5
0B90:  RETURN  
....................     } 
....................      
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MOTOR_H */ 
....................  
....................  
.................... #include <config.h> 
.................... /*  
....................  * File:   config.h 
....................  * Author: Arsapol 
....................  * 
....................  * Created on October 23, 2016, 2:08 AM 
....................  */ 
....................  
.................... #ifndef CONFIG_H 
.................... #define	CONFIG_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................      
.................... #define DRIVE_MOTOR_X   1 
.................... #define DRIVE_MOTOR_Y   2 
....................      
.................... #define MOTOR_HZ        5 
....................  
.................... #define MOTOR_X_PWM     PIN_B0 
.................... #define MOTOR_Y_PWM     PIN_B1 
.................... //#define MOTOR_Z_PWM     PIN_B2 
....................      
.................... #define MOTOR_X_DIR     PIN_B4 
.................... #define MOTOR_Y_DIR     PIN_B5 
.................... //#define MOTOR_Z_DIR     PIN_B6 
....................      
.................... #define ENCODER_X_A     0 
.................... #define ENCODER_Y_A     1     
.................... #define ENCODER_X_B     PIN_B3 
.................... #define ENCODER_Y_B     PIN_B2 
.................... //#define ENCODER_Z_B     PIN_B13 
....................      
.................... //#define TIMES_PER_ROUND 5 
....................      
....................     /* 
....................  ****************Note****************** 
....................  * INT0[Ex] - Encoder Axis X 
....................  * INT1[Ex] - Encoder Axis Y 
....................  * INT2[In] - PWM Timer2 
....................  * INT3[Ex] -                                  (deleted) Encoder Axis Z 
....................  * INT4[ ] -  
....................  *  
....................  * PIN_A0  -  
....................  * PIN_A1  -  
....................  * PIN_A2  -  
....................  * PIN_A3  -  
....................  * PIN_A4  -  
....................  * PIN_B0  - [OUT] AN2 : PWM_MOTOR_X 
....................  * PIN_B1  - [OUT] AN3 : PWM_MOTOR_Y 
....................  * PIN_B2  - [IN]  AN5 : B_Y (Encoder signal B) /                                
....................  * PIN_B3  - [IN]  AN5 : B_X (Encoder signal B) / 
....................  * PIN_B4  - [OUT] DIR_X / 
....................  * PIN_B5  - [OUT] DIR_Y / 
....................  * PIN_B6  -                                    
....................  * PIN_B7  - [IN] INT0 : Read Encoder X 
....................  * PIN_B8  - [IN] INT1 : Read Encoder Y  
....................  * PIN_B9  -                                    
....................  * PIN_B10 -  
....................  * PIN_B11 -  
....................  * PIN_B12 - [IN]  AN12 : B_Y (Encoder signal B) / 
....................  * PIN_B13 - RX                                   
....................  * PIN_B14 - TX 
....................  * PIN_B15 -  
....................  * PIN_B16 -  
....................  */ 
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* CONFIG_H */ 
....................  
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h>  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
*
0C0C:  MOV     W5,[W15++]
0C0E:  MOV     W6,[W15++]
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
0C10:  CLR     892
....................    sign = 0; 
0C12:  CLR     88E
....................    base = 10; 
0C14:  MOV     #A,W4
0C16:  MOV     W4,890
....................    result = 0; 
0C18:  CLR     88C
....................  
....................    if (!s) 
0C1A:  CP0     88A
0C1C:  BRA     NZ,C22
....................       return 0; 
0C1E:  CLR     0
0C20:  BRA     DA2
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
0C22:  MOV     892,W0
0C24:  INC     0892
0C26:  MOV     W0,W5
0C28:  MOV     W5,W0
0C2A:  ADD     88A,W0
0C2C:  MOV     894,W4
0C2E:  MOV.B   [W0+#0],W4L
0C30:  MOV     W4,894
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0C32:  MOV     894,W4
0C34:  XOR.B   #2D,W4L
0C36:  BRA     NZ,C4E
....................    { 
....................       sign = 1;         // Set the sign to negative 
0C38:  MOV     #1,W4
0C3A:  MOV     W4,88E
....................       c = s[index++]; 
0C3C:  MOV     892,W0
0C3E:  INC     0892
0C40:  MOV     W0,W5
0C42:  MOV     W5,W0
0C44:  ADD     88A,W0
0C46:  MOV     894,W4
0C48:  MOV.B   [W0+#0],W4L
0C4A:  MOV     W4,894
....................    } 
0C4C:  BRA     C64
....................    else if (c == '+') 
0C4E:  MOV     894,W4
0C50:  XOR.B   #2B,W4L
0C52:  BRA     NZ,C64
....................    { 
....................       c = s[index++]; 
0C54:  MOV     892,W0
0C56:  INC     0892
0C58:  MOV     W0,W5
0C5A:  MOV     W5,W0
0C5C:  ADD     88A,W0
0C5E:  MOV     894,W4
0C60:  MOV.B   [W0+#0],W4L
0C62:  MOV     W4,894
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0C64:  MOV     894,W4
0C66:  MOV     #30,W3
0C68:  CP.B    W3L,W4L
0C6A:  BRA     GT,D8A
0C6C:  MOV     894,W4
0C6E:  MOV     #39,W3
0C70:  CP.B    W3L,W4L
0C72:  BRA     LT,D8A
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0C74:  MOV     894,W4
0C76:  XOR.B   #30,W4L
0C78:  BRA     NZ,CA4
0C7A:  MOV     892,W0
0C7C:  ADD     88A,W0
0C7E:  MOV.B   [W0],W4L
0C80:  XOR.B   #78,W4L
0C82:  BRA     Z,C8E
0C84:  MOV     892,W0
0C86:  ADD     88A,W0
0C88:  MOV.B   [W0],W4L
0C8A:  XOR.B   #58,W4L
0C8C:  BRA     NZ,CA4
....................       { 
....................          base = 16; 
0C8E:  MOV     #10,W4
0C90:  MOV     W4,890
....................          index++; 
0C92:  INC     0892
....................          c = s[index++]; 
0C94:  MOV     892,W0
0C96:  INC     0892
0C98:  MOV     W0,W5
0C9A:  MOV     W5,W0
0C9C:  ADD     88A,W0
0C9E:  MOV     894,W4
0CA0:  MOV.B   [W0+#0],W4L
0CA2:  MOV     W4,894
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0CA4:  MOV     890,W4
0CA6:  CP      W4,#A
0CA8:  BRA     NZ,CE2
....................       { 
....................          while (c >= '0' && c <= '9') 
0CAA:  MOV     894,W4
0CAC:  MOV     #30,W3
0CAE:  CP.B    W3L,W4L
0CB0:  BRA     GT,CE0
0CB2:  MOV     894,W4
0CB4:  MOV     #39,W3
0CB6:  CP.B    W3L,W4L
0CB8:  BRA     LT,CE0
....................          { 
....................             result = 10*result + (c - '0'); 
0CBA:  MOV     88C,W4
0CBC:  MUL.UU  W4,#A,W0
0CBE:  MOV     W0,W5
0CC0:  MOV     894,W4
0CC2:  SUB.B   #30,W4L
0CC4:  MOV.B   W4L,W0L
0CC6:  MOV.B   W0L,0
0CC8:  SE      W0,W0
0CCA:  ADD     W0,W5,W0
0CCC:  MOV     W0,88C
....................             c = s[index++]; 
0CCE:  MOV     892,W0
0CD0:  INC     0892
0CD2:  MOV     W0,W5
0CD4:  MOV     W5,W0
0CD6:  ADD     88A,W0
0CD8:  MOV     894,W4
0CDA:  MOV.B   [W0+#0],W4L
0CDC:  MOV     W4,894
0CDE:  BRA     CAA
....................          } 
....................       } 
0CE0:  BRA     D8A
....................       else if (base == 16)    // The number is a hexa number 
0CE2:  MOV     890,W4
0CE4:  CP      W4,#10
0CE6:  BRA     NZ,D8A
....................       { 
....................          c = toupper(c); 
0CE8:  MOV     894,W4
0CEA:  MOV     #61,W3
0CEC:  CP.B    W3L,W4L
0CEE:  BRA     GTU,CFE
0CF0:  MOV     894,W4
0CF2:  MOV     #7A,W3
0CF4:  CP.B    W3L,W4L
0CF6:  BRA     NC,CFE
0CF8:  MOV.B   894,W0L
0CFA:  AND.B   #DF,W0L
0CFC:  BRA     D00
0CFE:  MOV.B   894,W0L
0D00:  MOV.B   W0L,894
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
0D02:  MOV     894,W4
0D04:  MOV     #30,W3
0D06:  CP.B    W3L,W4L
0D08:  BRA     GT,D14
0D0A:  MOV     894,W4
0D0C:  MOV     #39,W3
0D0E:  CP.B    W3L,W4L
0D10:  BRA     LT,D14
0D12:  BRA     D24
0D14:  MOV     894,W4
0D16:  MOV     #41,W3
0D18:  CP.B    W3L,W4L
0D1A:  BRA     GT,D8A
0D1C:  MOV     894,W4
0D1E:  MOV     #46,W3
0D20:  CP.B    W3L,W4L
0D22:  BRA     LT,D8A
....................          { 
....................             if (c >= '0' && c <= '9') 
0D24:  MOV     894,W4
0D26:  MOV     #30,W3
0D28:  CP.B    W3L,W4L
0D2A:  BRA     GT,D48
0D2C:  MOV     894,W4
0D2E:  MOV     #39,W3
0D30:  CP.B    W3L,W4L
0D32:  BRA     LT,D48
....................                result = (result << 4) + (c - '0'); 
0D34:  MOV     88C,W5
0D36:  SL      W5,#4,W5
0D38:  MOV     894,W4
0D3A:  SUB.B   #30,W4L
0D3C:  MOV.B   W4L,W0L
0D3E:  MOV.B   W0L,0
0D40:  SE      W0,W0
0D42:  ADD     W0,W5,W0
0D44:  MOV     W0,88C
0D46:  BRA     D5E
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0D48:  MOV     88C,W5
0D4A:  SL      W5,#4,W5
0D4C:  MOV     894,W4
0D4E:  SUB.B   #41,W4L
0D50:  MOV.B   W4L,W0L
0D52:  MOV.B   W0L,0
0D54:  ZE      W0,W0
0D56:  CLR.B   1
0D58:  ADD     W0,#A,W0
0D5A:  ADD     W0,W5,W0
0D5C:  MOV     W0,88C
....................  
....................             c = s[index++]; 
0D5E:  MOV     892,W0
0D60:  INC     0892
0D62:  MOV     W0,W5
0D64:  MOV     W5,W0
0D66:  ADD     88A,W0
0D68:  MOV     894,W4
0D6A:  MOV.B   [W0+#0],W4L
0D6C:  MOV     W4,894
....................             c = toupper(c); 
0D6E:  MOV     894,W4
0D70:  MOV     #61,W3
0D72:  CP.B    W3L,W4L
0D74:  BRA     GTU,D84
0D76:  MOV     894,W4
0D78:  MOV     #7A,W3
0D7A:  CP.B    W3L,W4L
0D7C:  BRA     NC,D84
0D7E:  MOV.B   894,W0L
0D80:  AND.B   #DF,W0L
0D82:  BRA     D86
0D84:  MOV.B   894,W0L
0D86:  MOV.B   W0L,894
0D88:  BRA     D02
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0D8A:  MOV     88E,W4
0D8C:  CP      W4,#1
0D8E:  BRA     NZ,D9E
0D90:  MOV     890,W4
0D92:  CP      W4,#A
0D94:  BRA     NZ,D9E
....................        result = -result; 
0D96:  MOV     #0,W4
0D98:  MOV     88C,W3
0D9A:  SUB     W4,W3,W0
0D9C:  MOV     W0,88C
....................  
....................    return(result); 
0D9E:  PUSH    88C
0DA0:  POP     0
0DA2:  MOV     [--W15],W6
0DA4:  MOV     [--W15],W5
0DA6:  RETURN  
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #fuses FRC_PLL 
.................... #use delay (clock = 32000000) 
.................... //#use delay (clock = 16000000) For Use in Hardware 
....................  
.................... #PIN_SELECT U1RX = PIN_B12 
.................... #PIN_SELECT U1TX = PIN_B13 
.................... #use rs232(baud=9600, UART1) 
....................  
.................... #use fixed_io(b_outputs= MOTOR_X_DIR, MOTOR_Y_DIR) //DIR x,y 
....................  
.................... #PIN_SELECT OC1 = MOTOR_X_PWM //PWM_MOTOR_X 
.................... #PIN_SELECT OC2 = MOTOR_Y_PWM //PWM_MOTOR_Y 
.................... #PIN_SELECT INT1 = PIN_B8 //Y Axis - X is INT0 
....................  
.................... #define RATE  0.1 
.................... #define Kc   0.5 
.................... #define Ti    0.0 
.................... #define Td    0.05 
.................... SPID Motor_X, Motor_Y; 
.................... Encoder En_x, En_y; 
.................... float plantCommand[2]={0}, position[2]={0}, drive[2]={0}; //plantCommand = goal position - x,y 
....................  
.................... int Z_Position = 0; 
....................  
.................... char SM_Buffer[20]; 
.................... int SM_Index = 0; 
.................... float data[2] = {0}; 
.................... int SM_Id = 1; 
.................... boolean isX = FALSE; 
.................... boolean state = FALSE; 
....................  
.................... void SM_RxD(char c) { 
*
0214:  MOV     W5,[W15++]
....................     switch (SM_Id) { 
0216:  MOV     87E,W0
0218:  XOR     #1,W0
021A:  BRA     Z,222
021C:  XOR     #3,W0
021E:  BRA     Z,242
0220:  BRA     266
....................         case 1: 
....................             if (c == ':') { //X data 
0222:  MOV     8CE,W4
0224:  XOR.B   #3A,W4L
0226:  BRA     NZ,232
....................                 isX = TRUE; 
0228:  BSET.B  880.0
....................                 SM_Index = 0; 
022A:  CLR     874
....................                 SM_Id = 2; 
022C:  MOV     #2,W4
022E:  MOV     W4,87E
....................             } else if (c == '!') { //Y data 
0230:  BRA     23E
0232:  MOV     8CE,W4
0234:  XOR.B   #21,W4L
0236:  BRA     NZ,23E
....................                 isX = FALSE; 
0238:  BCLR.B  880.0
....................                 SM_Id = 2; 
023A:  MOV     #2,W4
023C:  MOV     W4,87E
....................             } 
....................             SM_Index = 0; 
023E:  CLR     874
....................             break; 
0240:  BRA     266
....................  
....................         case 2: 
....................             if (c == '#') { 
0242:  MOV     8CE,W4
0244:  XOR.B   #23,W4L
0246:  BRA     NZ,258
....................                 SM_Buffer[SM_Index] = '\0'; 
0248:  MOV     #860,W4
024A:  MOV     874,W3
024C:  ADD     W3,W4,W5
024E:  CLR.B   [W5]
....................                 state = TRUE; 
0250:  BSET.B  880.1
....................                 SM_Id = 1; 
0252:  MOV     #1,W4
0254:  MOV     W4,87E
....................             } else { 
0256:  BRA     264
....................                 SM_Buffer[SM_Index] = c; 
0258:  MOV     #860,W4
025A:  MOV     874,W3
025C:  ADD     W3,W4,W5
025E:  MOV     8CE,W0
0260:  MOV.B   W0L,[W5+#0]
....................                 SM_Index++; 
0262:  INC     0874
....................             } 
....................             break; 
0264:  BRA     266
....................     } 
0266:  MOV     [--W15],W5
0268:  RETURN  
.................... } 
....................  
.................... #INT_RDA 
....................  
.................... void UART1_Isr() { 
026A:  PUSH    42
026C:  PUSH    36
026E:  PUSH    32
0270:  MOV     W0,[W15++]
0272:  MOV     #2,W0
0274:  REPEAT  #C
0276:  MOV     [W0++],[W15++]
0278:  BTSS.B  222.0
027A:  BRA     278
027C:  MOV     226,W0
027E:  MOV.B   W0L,8CC
....................     char c = getc(); 
....................     SM_RxD(c); 
0280:  MOV.B   8CC,W0L
0282:  MOV.B   W0L,8CE
0284:  CALL    214
0288:  BCLR.B  85.3
028A:  MOV     #1A,W0
028C:  REPEAT  #C
028E:  MOV     [--W15],[W0--]
0290:  MOV     [--W15],W0
0292:  POP     32
0294:  POP     36
0296:  POP     42
0298:  RETFIE  
.................... } 
....................  
.................... void Init_ADC() { 
....................     setup_adc_ports(sAN0, VSS_VDD); 
*
0B54:  MOV     #FFFE,W4
0B56:  MOV     W4,32C
0B58:  CLR     322
....................     setup_adc(ADC_CLOCK_DIV_32); 
0B5A:  MOV     #1F1F,W4
0B5C:  MOV     W4,324
0B5E:  MOV     #80E0,W4
0B60:  MOV     W4,320
....................     set_adc_channel(0); 
0B62:  CLR     328
....................     delay_us(10); 
0B64:  REPEAT  #9E
0B66:  NOP     
0B68:  RETURN  
.................... } 
....................  
.................... void Change_ADC_Read_Channel(int channel) { 
....................     set_adc_channel(channel); 
0B6A:  PUSH    88A
0B6C:  POP     328
....................     delay_us(10); 
0B6E:  REPEAT  #9E
0B70:  NOP     
0B72:  RETURN  
.................... } 
....................  
.................... void Control_Motor(int motor_num, float speed_velo) { 
....................     if (motor_num == DRIVE_MOTOR_X) { 
*
0958:  MOV     8C6,W4
095A:  CP      W4,#1
095C:  BRA     NZ,982
....................         if (speed_velo >= 0) output_high(MOTOR_X_DIR); 
095E:  MOV     #0,W0
0960:  MOV     #0,W1
0962:  MOV     8C8,W2
0964:  MOV     8CA,W3
0966:  CALL    7C8
096A:  BRA     C,96E
096C:  BRA     NZ,976
096E:  MOV     #FFCF,W4
0970:  MOV     W4,2C8
0972:  BSET.B  2CC.4
0974:  BRA     97C
....................         else output_low(MOTOR_X_DIR); 
0976:  MOV     #FFCF,W4
0978:  MOV     W4,2C8
097A:  BCLR.B  2CC.4
....................         set_pwm_duty(DRIVE_MOTOR_X, speed_velo); 
097C:  PUSH    8C8
097E:  POP     180
....................     } else if (motor_num == DRIVE_MOTOR_Y) { 
0980:  BRA     9AA
0982:  MOV     8C6,W4
0984:  CP      W4,#2
0986:  BRA     NZ,9AA
....................         if (speed_velo >= 0) output_high(MOTOR_Y_DIR); 
0988:  MOV     #0,W0
098A:  MOV     #0,W1
098C:  MOV     8C8,W2
098E:  MOV     8CA,W3
0990:  CALL    7C8
0994:  BRA     C,998
0996:  BRA     NZ,9A0
0998:  MOV     #FFCF,W4
099A:  MOV     W4,2C8
099C:  BSET.B  2CC.5
099E:  BRA     9A6
....................         else output_low(MOTOR_Y_DIR); 
09A0:  MOV     #FFCF,W4
09A2:  MOV     W4,2C8
09A4:  BCLR.B  2CC.5
....................         set_pwm_duty(DRIVE_MOTOR_Y, speed_velo); 
09A6:  PUSH    8C8
09A8:  POP     186
....................     } 
09AA:  RETURN  
.................... } 
....................  
.................... #INT_EXT0 
....................  
.................... void INT_EXT_INPUT0(void) { //X Axis 
09AC:  PUSH    42
09AE:  PUSH    36
09B0:  PUSH    32
09B2:  MOV     W0,[W15++]
09B4:  MOV     #2,W0
09B6:  REPEAT  #C
09B8:  MOV     [W0++],[W15++]
....................     //Read Pulse from Encoder and compare pulse A and B 
....................     En_x.B_signal = input(ENCODER_X_B); 
09BA:  MOV     #FFCF,W4
09BC:  MOV     W4,2C8
09BE:  CLR     83E
09C0:  BTSC.B  2CA.3
09C2:  INC     083E
....................     if (En_x.B_signal == 0) En_x.Pulses += 1; 
09C4:  CP0     83E
09C6:  BRA     NZ,9D0
09C8:  MOV     840,W4
09CA:  ADD     W4,#1,W4
09CC:  MOV     W4,840
09CE:  BRA     9D6
....................     else En_x.Pulses -= 1; 
09D0:  MOV     840,W4
09D2:  SUB     W4,#1,W0
09D4:  MOV     W0,840
....................  
....................     position[0] = En_x.Pulses * Position_Per_Pulse; //Times of twist for 1 round ****************Need Test for TIMES_PER_ROUND 
09D6:  MOV     840,W0
09D8:  CLR     W3
09DA:  BTSC    W0.F
09DC:  SETM    W3
09DE:  MOV     W3,W1
09E0:  MOV     W3,W2
09E2:  CALL    29A
09E6:  MOV     #F255,W4
09E8:  MOV     #769C,W5
09EA:  MOV     #1B2F,W6
09EC:  MOV     #4004,W7
09EE:  CALL    2FE
09F2:  MOV     W0,W5
09F4:  MOV     W1,W6
09F6:  MOV     W2,W7
09F8:  MOV     W3,W8
09FA:  MOV     W5,[W15++]
09FC:  MOV     W6,[W15++]
09FE:  MOV     W7,[W15++]
0A00:  MOV     W5,W0
0A02:  MOV     W6,W1
0A04:  MOV     W7,W2
0A06:  MOV     W8,W3
0A08:  MOV     #0,W4
0A0A:  MOV     #0,W5
0A0C:  MOV     #0,W6
0A0E:  MOV     #4079,W7
0A10:  CALL    40E
0A14:  MOV     [--W15],W7
0A16:  MOV     [--W15],W6
0A18:  MOV     [--W15],W5
0A1A:  CALL    516
0A1E:  MOV     W1,84E
0A20:  MOV     W2,850
....................     drive[0] = UpdatePID(&Motor_X, (plantCommand[0] - position[0]), position[0]); 
0A22:  BSET.B  43.0
0A24:  MOV     846,W0
0A26:  MOV     848,W1
0A28:  MOV     84E,W2
0A2A:  MOV     850,W3
0A2C:  CALL    55A
0A30:  MOV     W0,W5
0A32:  MOV     W1,W6
0A34:  MOV     #806,W4
0A36:  MOV     W4,8D2
0A38:  MOV     W5,8D4
0A3A:  MOV     W6,8D6
0A3C:  PUSH    84E
0A3E:  POP     8D8
0A40:  PUSH    850
0A42:  POP     8DA
0A44:  CALL    830
0A48:  MOV     W0,856
0A4A:  MOV     W1,858
....................     Control_Motor(DRIVE_MOTOR_X, drive[0]); 
0A4C:  MOV     #1,W4
0A4E:  MOV     W4,8C6
0A50:  PUSH    856
0A52:  POP     8C8
0A54:  PUSH    858
0A56:  POP     8CA
0A58:  CALL    958
.................... } 
....................  
0A5C:  BCLR.B  84.0
0A5E:  MOV     #1A,W0
0A60:  REPEAT  #C
0A62:  MOV     [--W15],[W0--]
0A64:  MOV     [--W15],W0
0A66:  POP     32
0A68:  POP     36
0A6A:  POP     42
0A6C:  RETFIE  
.................... #INT_EXT1 
....................  
.................... void INT_EXT_INPUT1(void) { //Y Axis 
0A6E:  PUSH    42
0A70:  PUSH    36
0A72:  PUSH    32
0A74:  MOV     W0,[W15++]
0A76:  MOV     #2,W0
0A78:  REPEAT  #C
0A7A:  MOV     [W0++],[W15++]
....................     //Read Pulse from Encoder and compare pulse A and B  
....................     En_y.B_signal = input(ENCODER_Y_B); 
0A7C:  MOV     #FFCF,W4
0A7E:  MOV     W4,2C8
0A80:  CLR     842
0A82:  BTSC.B  2CA.2
0A84:  INC     0842
....................     if (En_y.B_signal == 0) En_y.Pulses += 1; 
0A86:  CP0     842
0A88:  BRA     NZ,A92
0A8A:  MOV     844,W4
0A8C:  ADD     W4,#1,W4
0A8E:  MOV     W4,844
0A90:  BRA     A98
....................     else En_y.Pulses -= 1; 
0A92:  MOV     844,W4
0A94:  SUB     W4,#1,W0
0A96:  MOV     W0,844
....................  
....................     position[1] = En_y.Pulses * Position_Per_Pulse; //Times of twist for 1 round ****************Need Test for TIMES_PER_ROUND 
0A98:  MOV     844,W0
0A9A:  CLR     W3
0A9C:  BTSC    W0.F
0A9E:  SETM    W3
0AA0:  MOV     W3,W1
0AA2:  MOV     W3,W2
0AA4:  CALL    29A
0AA8:  MOV     #F255,W4
0AAA:  MOV     #769C,W5
0AAC:  MOV     #1B2F,W6
0AAE:  MOV     #4004,W7
0AB0:  CALL    2FE
0AB4:  MOV     W0,W5
0AB6:  MOV     W1,W6
0AB8:  MOV     W2,W7
0ABA:  MOV     W3,W8
0ABC:  MOV     W5,[W15++]
0ABE:  MOV     W6,[W15++]
0AC0:  MOV     W7,[W15++]
0AC2:  MOV     W5,W0
0AC4:  MOV     W6,W1
0AC6:  MOV     W7,W2
0AC8:  MOV     W8,W3
0ACA:  MOV     #0,W4
0ACC:  MOV     #0,W5
0ACE:  MOV     #0,W6
0AD0:  MOV     #4079,W7
0AD2:  CALL    40E
0AD6:  MOV     [--W15],W7
0AD8:  MOV     [--W15],W6
0ADA:  MOV     [--W15],W5
0ADC:  CALL    516
0AE0:  MOV     W1,852
0AE2:  MOV     W2,854
....................     drive[1] = UpdatePID(&Motor_Y, (plantCommand[1] - position[1]), position[1]); 
0AE4:  BSET.B  43.0
0AE6:  MOV     84A,W0
0AE8:  MOV     84C,W1
0AEA:  MOV     852,W2
0AEC:  MOV     854,W3
0AEE:  CALL    55A
0AF2:  MOV     W0,W5
0AF4:  MOV     W1,W6
0AF6:  MOV     #822,W4
0AF8:  MOV     W4,8D2
0AFA:  MOV     W5,8D4
0AFC:  MOV     W6,8D6
0AFE:  PUSH    852
0B00:  POP     8D8
0B02:  PUSH    854
0B04:  POP     8DA
0B06:  CALL    830
0B0A:  MOV     W0,85A
0B0C:  MOV     W1,85C
....................     Control_Motor(DRIVE_MOTOR_Y, drive[1]); 
0B0E:  MOV     #2,W4
0B10:  MOV     W4,8C6
0B12:  PUSH    85A
0B14:  POP     8C8
0B16:  PUSH    85C
0B18:  POP     8CA
0B1A:  CALL    958
0B1E:  BCLR.B  86.4
0B20:  MOV     #1A,W0
0B22:  REPEAT  #C
0B24:  MOV     [--W15],[W0--]
0B26:  MOV     [--W15],W0
0B28:  POP     32
0B2A:  POP     36
0B2C:  POP     42
0B2E:  RETFIE  
.................... } 
....................  
.................... void Init_Interrupts() { 
....................     enable_interrupts(INT_EXT0); 
0B30:  BSET.B  94.0
....................     ext_int_edge(ENCODER_X_A, L_TO_H); // Rising Edge 
0B32:  BCLR.B  82.0
....................     enable_interrupts(INT_EXT1); 
0B34:  BSET.B  96.4
....................     ext_int_edge(ENCODER_Y_A, L_TO_H); // Rising Edge 
0B36:  BCLR.B  82.1
....................     enable_interrupts(INT_RDA); 
0B38:  BSET.B  95.3
0B3A:  RETURN  
.................... } 
....................  
.................... void Init_MotorPWM() { 
....................     setup_timer3(TMR_INTERNAL | TMR_DIV_BY_64, MOTOR_HZ); 
0B3C:  CLR     112
0B3E:  MOV     #5,W4
0B40:  MOV     W4,10E
0B42:  MOV     #8020,W4
0B44:  MOV     W4,112
....................     setup_compare(DRIVE_MOTOR_X, COMPARE_PWM | COMPARE_TIMER3); 
0B46:  MOV     #E,W4
0B48:  MOV     W4,184
....................     set_pwm_duty(DRIVE_MOTOR_X, 0); 
0B4A:  CLR     180
....................     setup_compare(DRIVE_MOTOR_Y, COMPARE_PWM | COMPARE_TIMER3); 
0B4C:  MOV     #E,W4
0B4E:  MOV     W4,18A
....................     set_pwm_duty(DRIVE_MOTOR_Y, 0); 
0B50:  CLR     186
0B52:  RETURN  
.................... } 
....................  
.................... void PID_X_Y() { 
*
0DA8:  MOV     W5,[W15++]
0DAA:  MOV     W6,[W15++]
0DAC:  MOV     W7,[W15++]
0DAE:  MOV     W8,[W15++]
....................     position[0] = En_x.Pulses * Position_Per_Pulse; //Times of twist for 1 round ****************Need Test for TIMES_PER_ROUND 
0DB0:  MOV     840,W0
0DB2:  CLR     W3
0DB4:  BTSC    W0.F
0DB6:  SETM    W3
0DB8:  MOV     W3,W1
0DBA:  MOV     W3,W2
0DBC:  CALL    29A
0DC0:  MOV     #F255,W4
0DC2:  MOV     #769C,W5
0DC4:  MOV     #1B2F,W6
0DC6:  MOV     #4004,W7
0DC8:  CALL    2FE
0DCC:  MOV     W0,W5
0DCE:  MOV     W1,W6
0DD0:  MOV     W2,W7
0DD2:  MOV     W3,W8
0DD4:  MOV     W5,[W15++]
0DD6:  MOV     W6,[W15++]
0DD8:  MOV     W7,[W15++]
0DDA:  PUSH    42
0DDC:  BCLR.B  81.7
0DDE:  SETM.B  42
0DE0:  BSET.B  81.7
0DE2:  MOV     W5,W0
0DE4:  MOV     W6,W1
0DE6:  MOV     W7,W2
0DE8:  MOV     W8,W3
0DEA:  MOV     #0,W4
0DEC:  MOV     #0,W5
0DEE:  MOV     #0,W6
0DF0:  MOV     #4079,W7
0DF2:  CALL    40E
0DF6:  BCLR.B  81.7
0DF8:  POP     42
0DFA:  BSET.B  81.7
0DFC:  MOV     [--W15],W7
0DFE:  MOV     [--W15],W6
0E00:  MOV     [--W15],W5
0E02:  CALL    516
0E06:  MOV     W1,84E
0E08:  MOV     W2,850
....................     drive[0] = UpdatePID(&Motor_X, (plantCommand[0] - position[0]), position[0]); 
0E0A:  BSET.B  43.0
0E0C:  PUSH    42
0E0E:  BCLR.B  81.7
0E10:  SETM.B  42
0E12:  BSET.B  81.7
0E14:  MOV     846,W0
0E16:  MOV     848,W1
0E18:  MOV     84E,W2
0E1A:  MOV     850,W3
0E1C:  CALL    55A
0E20:  BCLR.B  81.7
0E22:  POP     42
0E24:  BSET.B  81.7
0E26:  MOV     W0,W5
0E28:  MOV     W1,W6
0E2A:  PUSH    42
0E2C:  BCLR.B  81.7
0E2E:  SETM.B  42
0E30:  BSET.B  81.7
0E32:  MOV     #806,W4
0E34:  MOV     W4,8D2
0E36:  MOV     W5,8D4
0E38:  MOV     W6,8D6
0E3A:  PUSH    84E
0E3C:  POP     8D8
0E3E:  PUSH    850
0E40:  POP     8DA
0E42:  CALL    830
0E46:  BCLR.B  81.7
0E48:  POP     42
0E4A:  BSET.B  81.7
0E4C:  MOV     W0,856
0E4E:  MOV     W1,858
0E50:  PUSH    42
0E52:  BCLR.B  81.7
0E54:  SETM.B  42
0E56:  BSET.B  81.7
....................     Control_Motor(DRIVE_MOTOR_X, drive[0]); 
0E58:  MOV     #1,W4
0E5A:  MOV     W4,8C6
0E5C:  PUSH    856
0E5E:  POP     8C8
0E60:  PUSH    858
0E62:  POP     8CA
0E64:  CALL    958
0E68:  BCLR.B  81.7
0E6A:  POP     42
0E6C:  BSET.B  81.7
....................  
....................     position[1] = En_y.Pulses * Position_Per_Pulse; //Times of twist for 1 round ****************Need Test for TIMES_PER_ROUND 
0E6E:  MOV     844,W0
0E70:  CLR     W3
0E72:  BTSC    W0.F
0E74:  SETM    W3
0E76:  MOV     W3,W1
0E78:  MOV     W3,W2
0E7A:  CALL    29A
0E7E:  MOV     #F255,W4
0E80:  MOV     #769C,W5
0E82:  MOV     #1B2F,W6
0E84:  MOV     #4004,W7
0E86:  CALL    2FE
0E8A:  MOV     W0,W5
0E8C:  MOV     W1,W6
0E8E:  MOV     W2,W7
0E90:  MOV     W3,W8
0E92:  MOV     W5,[W15++]
0E94:  MOV     W6,[W15++]
0E96:  MOV     W7,[W15++]
0E98:  PUSH    42
0E9A:  BCLR.B  81.7
0E9C:  SETM.B  42
0E9E:  BSET.B  81.7
0EA0:  MOV     W5,W0
0EA2:  MOV     W6,W1
0EA4:  MOV     W7,W2
0EA6:  MOV     W8,W3
0EA8:  MOV     #0,W4
0EAA:  MOV     #0,W5
0EAC:  MOV     #0,W6
0EAE:  MOV     #4079,W7
0EB0:  CALL    40E
0EB4:  BCLR.B  81.7
0EB6:  POP     42
0EB8:  BSET.B  81.7
0EBA:  MOV     [--W15],W7
0EBC:  MOV     [--W15],W6
0EBE:  MOV     [--W15],W5
0EC0:  CALL    516
0EC4:  MOV     W1,852
0EC6:  MOV     W2,854
....................     drive[1] = UpdatePID(&Motor_Y, (plantCommand[1] - position[1]), position[1]); 
0EC8:  BSET.B  43.0
0ECA:  PUSH    42
0ECC:  BCLR.B  81.7
0ECE:  SETM.B  42
0ED0:  BSET.B  81.7
0ED2:  MOV     84A,W0
0ED4:  MOV     84C,W1
0ED6:  MOV     852,W2
0ED8:  MOV     854,W3
0EDA:  CALL    55A
0EDE:  BCLR.B  81.7
0EE0:  POP     42
0EE2:  BSET.B  81.7
0EE4:  MOV     W0,W5
0EE6:  MOV     W1,W6
0EE8:  PUSH    42
0EEA:  BCLR.B  81.7
0EEC:  SETM.B  42
0EEE:  BSET.B  81.7
0EF0:  MOV     #822,W4
0EF2:  MOV     W4,8D2
0EF4:  MOV     W5,8D4
0EF6:  MOV     W6,8D6
0EF8:  PUSH    852
0EFA:  POP     8D8
0EFC:  PUSH    854
0EFE:  POP     8DA
0F00:  CALL    830
0F04:  BCLR.B  81.7
0F06:  POP     42
0F08:  BSET.B  81.7
0F0A:  MOV     W0,85A
0F0C:  MOV     W1,85C
0F0E:  PUSH    42
0F10:  BCLR.B  81.7
0F12:  SETM.B  42
0F14:  BSET.B  81.7
....................     Control_Motor(DRIVE_MOTOR_Y, drive[1]); 
0F16:  MOV     #2,W4
0F18:  MOV     W4,8C6
0F1A:  PUSH    85A
0F1C:  POP     8C8
0F1E:  PUSH    85C
0F20:  POP     8CA
0F22:  CALL    958
0F26:  BCLR.B  81.7
0F28:  POP     42
0F2A:  BSET.B  81.7
0F2C:  MOV     [--W15],W8
0F2E:  MOV     [--W15],W7
0F30:  MOV     [--W15],W6
0F32:  MOV     [--W15],W5
0F34:  RETURN  
.................... } 
....................  
.................... /*volatile float leftPulses = 0; 
.................... volatile float leftPrevPulses = 0; 
.................... volatile float leftPwmDuty = 1.0; 
.................... volatile float leftVelocity = 0.0; 
....................  
.................... volatile float rightPulses = 0; 
.................... volatile float rightPrevPulses = 0; 
.................... volatile float rightPwmDuty = 1.0; 
.................... volatile float rightVelocity = 0.0;*/ 
....................  
....................  
.................... void main() { 
*
138E:  MOV     #2780,W15
1390:  MOV     #27FF,W0
1392:  MOV     W0,20
1394:  NOP     
1396:  MOV     #4444,W0
1398:  MOV     W0,A8
139A:  BSET.B  81.7
139C:  MOV     #46,W0
139E:  MOV.B   W0L,742
13A0:  MOV     #57,W0
13A2:  MOV.B   W0L,742
13A4:  BCLR.B  742.6
13A6:  MOV     #83F,W0
13A8:  MOV     W0,680
13AA:  MOV     #3F0C,W0
13AC:  MOV     W0,6A4
13AE:  MOV     #1312,W0
13B0:  MOV     W0,6C0
13B2:  MOV     #300,W0
13B4:  MOV     W0,6CC
13B6:  MOV     #46,W0
13B8:  MOV.B   W0L,742
13BA:  MOV     #57,W0
13BC:  MOV.B   W0L,742
13BE:  BSET.B  742.6
13C0:  MOV     #8000,W4
13C2:  MOV     W4,220
13C4:  MOV     #400,W4
13C6:  MOV     W4,222
13C8:  BSET.B  220.3
13CA:  MOV     #1A0,W4
13CC:  MOV     W4,228
13CE:  CLR     85E
13D0:  CLR     874
13D2:  MOV     #1,W4
13D4:  MOV     W4,87E
13D6:  BCLR.B  880.0
13D8:  BCLR.B  880.1
13DA:  SETM    32C
13DC:  CLR     800
13DE:  CLR     846
13E0:  CLR     848
13E2:  CLR     84A
13E4:  CLR     84C
13E6:  CLR     84E
13E8:  CLR     850
13EA:  CLR     852
13EC:  CLR     854
13EE:  CLR     856
13F0:  CLR     858
13F2:  CLR     85A
13F4:  CLR     85C
13F6:  CLR     876
13F8:  CLR     878
13FA:  CLR     87A
13FC:  CLR     87C
....................     disable_interrupts(GLOBAL); 
13FE:  BCLR.B  81.7
1400:  MOV     #E0,W4
1402:  MOV     W4,42
1404:  BSET.B  81.7
....................     clear_interrupt(INT_RDA); 
1406:  REPEAT  #3
1408:  MOV     226,W0
140A:  BCLR.B  85.3
....................     Init_Interrupts(); 
140C:  CALL    B30
....................     Init_MotorPWM(); 
1410:  CALL    B3C
....................     enable_interrupts(GLOBAL); 
1414:  BCLR.B  81.7
1416:  CLR     42
1418:  BSET.B  81.7
....................  
....................     //ADC 
....................     Init_ADC(); 
141A:  CALL    B54
....................     Change_ADC_Read_Channel(0); 
141E:  CLR     88A
1420:  CALL    B6A
....................  
....................     //Encoder 
....................     Encoder_Init(&En_x); 
1424:  MOV     #83E,W4
1426:  MOV     W4,88A
1428:  CALL    B74
....................     Encoder_Init(&En_y); 
142C:  MOV     #842,W4
142E:  MOV     W4,88A
1430:  CALL    B74
....................  
....................     //PID 
....................     PID_Init(&Motor_X, Kc, Ti, Td); 
1434:  MOV     #806,W4
1436:  MOV     W4,88A
1438:  CLR     88C
143A:  MOV     #3F00,W4
143C:  MOV     W4,88E
143E:  CLR     890
1440:  CLR     892
1442:  MOV     #CCCD,W4
1444:  MOV     W4,894
1446:  MOV     #3D4C,W4
1448:  MOV     W4,896
144A:  CALL    B92
....................     PID_Init(&Motor_Y, Kc, Ti, Td); 
144E:  MOV     #822,W4
1450:  MOV     W4,88A
1452:  CLR     88C
1454:  MOV     #3F00,W4
1456:  MOV     W4,88E
1458:  CLR     890
145A:  CLR     892
145C:  MOV     #CCCD,W4
145E:  MOV     W4,894
1460:  MOV     #3D4C,W4
1462:  MOV     W4,896
1464:  CALL    B92
....................  
....................     int Z_Position = 0; 
1468:  CLR     882
....................  
....................     printf("Main\r\n"); 
146A:  MOV     #0,W1
146C:  MOV     W1,W0
146E:  CLR.B   1
1470:  CALL    200
1474:  INC     W1,W1
1476:  BTSC.B  223.1
1478:  BRA     1476
147A:  MOV     W0,224
147C:  MOV     #5,W0
147E:  CPSGT   W1,W0
1480:  BRA     146C
....................     while (TRUE) { 
....................         int temp = read_adc(); 
1482:  BCLR.B  320.0
1484:  BSET.B  320.1
1486:  BTSS.B  320.0
1488:  BRA     1486
148A:  PUSH    300
148C:  POP     884
....................         if(temp != 0) 
148E:  CP0     884
1490:  BRA     Z,1496
....................             Z_Position = temp; 
1492:  PUSH    884
1494:  POP     882
....................          
....................         if (state == TRUE) { 
1496:  BTSS.B  880.1
1498:  BRA     157C
....................             int int_buffer = atoi(SM_Buffer); 
149A:  MOV     #860,W4
149C:  MOV     W4,88A
149E:  CALL    C0C
14A2:  MOV     W0,886
....................             if (isX == TRUE) 
14A4:  BTSS.B  880.0
14A6:  BRA     14DC
....................                 data[0] = int_buffer / 1000.0; 
14A8:  MOV     886,W0
14AA:  CLR     W3
14AC:  BTSC    W0.F
14AE:  SETM    W3
14B0:  MOV     W3,W1
14B2:  MOV     W3,W2
14B4:  CALL    29A
14B8:  PUSH    42
14BA:  BCLR.B  81.7
14BC:  SETM.B  42
14BE:  BSET.B  81.7
14C0:  MOV     #0,W4
14C2:  MOV     #0,W5
14C4:  MOV     #4000,W6
14C6:  MOV     #408F,W7
14C8:  CALL    40E
14CC:  BCLR.B  81.7
14CE:  POP     42
14D0:  BSET.B  81.7
14D2:  CALL    516
14D6:  MOV     W1,876
14D8:  MOV     W2,878
14DA:  BRA     150E
....................             else 
....................                 data[1] = int_buffer / 1000.0; 
14DC:  MOV     886,W0
14DE:  CLR     W3
14E0:  BTSC    W0.F
14E2:  SETM    W3
14E4:  MOV     W3,W1
14E6:  MOV     W3,W2
14E8:  CALL    29A
14EC:  PUSH    42
14EE:  BCLR.B  81.7
14F0:  SETM.B  42
14F2:  BSET.B  81.7
14F4:  MOV     #0,W4
14F6:  MOV     #0,W5
14F8:  MOV     #4000,W6
14FA:  MOV     #408F,W7
14FC:  CALL    40E
1500:  BCLR.B  81.7
1502:  POP     42
1504:  BSET.B  81.7
1506:  CALL    516
150A:  MOV     W1,87A
150C:  MOV     W2,87C
....................             plantCommand[0] = data[0]; 
150E:  PUSH    876
1510:  POP     846
1512:  PUSH    878
1514:  POP     848
....................             plantCommand[1] = data[1]; 
1516:  PUSH    87A
1518:  POP     84A
151A:  PUSH    87C
151C:  POP     84C
....................              
....................             PID_X_Y(); 
151E:  CALL    DA8
....................              
....................             state = FALSE; 
1522:  BCLR.B  880.1
....................              
....................             printf("%e  %e  %d\r\n",plantCommand[0],plantCommand[1],Z_Position); 
1524:  MOV     848,W2
1526:  MOV     846,W1
1528:  MOV     #0,W0
152A:  CALL    F36
152E:  MOV     #204,W4
1530:  CALL    F7C
1534:  BTSC.B  223.1
1536:  BRA     1534
1538:  MOV     #20,W4
153A:  MOV     W4,224
153C:  BTSC.B  223.1
153E:  BRA     153C
1540:  MOV     #20,W4
1542:  MOV     W4,224
1544:  MOV     84C,W2
1546:  MOV     84A,W1
1548:  MOV     #0,W0
154A:  CALL    F36
154E:  MOV     #204,W4
1550:  CALL    F7C
1554:  BTSC.B  223.1
1556:  BRA     1554
1558:  MOV     #20,W4
155A:  MOV     W4,224
155C:  BTSC.B  223.1
155E:  BRA     155C
1560:  MOV     #20,W4
1562:  MOV     W4,224
1564:  MOV     882,W0
1566:  MOV     #0,W4
1568:  CALL    1298
156C:  BTSC.B  223.1
156E:  BRA     156C
1570:  MOV     #D,W4
1572:  MOV     W4,224
1574:  BTSC.B  223.1
1576:  BRA     1574
1578:  MOV     #A,W4
157A:  MOV     W4,224
....................         } 
157C:  BRA     1482
....................  
....................     } 
.................... } 
....................  
157E:  PWRSAV  #0

Configuration Fuses:
   Word  1L: 3F7F   WPOSTS16 WDT128 WINDIS NOWDT ICSP1 NODEBUG NOWRT NOPROTECT NOJTAG
          H: FF00  
   Word  2L: F9F7   NOPR NOALTI2C1 IOL1WAY NOOSCIO FRC_PLL SOSC_SEC WUT_DEFAULT IESO
          H: FF00  
