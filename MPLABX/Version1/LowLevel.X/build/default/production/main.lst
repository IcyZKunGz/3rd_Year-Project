CCS PCD C Compiler, Version 5.015, 5967               26-µ.¤.-16 15:09

               Filename:   E:\3rd Year\Term1\Cookies\MPLABX\Version1\LowLevel.X\build\default\production\main.lst

               ROM used:   5628 bytes (17%)
                           Largest free fragment is 28160
               RAM used:   260 (3%) at main() level
                           382 (5%) worst case
               Stack size: 128

*
0000:  GOTO    1404
*
0014:  DATA    FE,09,00
*
002A:  DATA    6A,02,00
*
003C:  DATA    CE,0A,00
.................... #include <24FJ48GA002.h> 
.................... //////////// Standard Header file for the PIC24FJ48GA002 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24FJ48GA002 
*
0200:  CLR     32
0202:  MOV     #20C,W3
0204:  ADD     W3,W0,W0
0206:  TBLRDL.B[W0],W0L
0208:  CLR.B   1
020A:  RETURN  
020C:  DATA    4D,61,00
020E:  DATA    69,6E,00
0210:  DATA    0D,0A,00
0212:  DATA    00,00,00
*
02C2:  MOV     W5,[W15++]
02C4:  MOV     #C,W5
02C6:  REPEAT  #3
02C8:  MOV     [W5++],[W15++]
02CA:  MOV     W0,W4
02CC:  MOV     W1,W5
02CE:  MOV     W2,W6
02D0:  MOV     W3,W7
02D2:  CLR     W0
02D4:  CLR     W1
02D6:  CLR     W2
02D8:  CLR     W3
02DA:  BCLR    W8.0
02DC:  BTSS    W7.F
02DE:  BRA     2EA
02E0:  BSET    W8.0
02E2:  NEG     W4,W4
02E4:  COM     W5,W5
02E6:  COM     W6,W6
02E8:  COM     W7,W7
02EA:  IOR      W4,  W5,W9
02EC:  BRA     NZ,2F2
02EE:  IOR      W6,  W7,W9
02F0:  BRA     Z,31C
02F2:  MOV     #473,W9
02F4:  BTSC    W3.4
02F6:  BRA     30E
02F8:  BCLR.B  42.0
02FA:  RLC     W4,W4
02FC:  RLC     W5,W5
02FE:  RLC     W6,W6
0300:  RLC     W7,W7
0302:  RLC     W0,W0
0304:  RLC     W1,W1
0306:  RLC     W2,W2
0308:  RLC     W3,W3
030A:  DEC     W9,W9
030C:  BRA     NZ,2F4
030E:  SL      W9,#4,W9
0310:  BCLR.B  42.0
0312:  BCLR    W9.F
0314:  BCLR    W3.4
0316:  XOR     W9,W3,W3
0318:  BTSC    W8.0
031A:  BSET    W3.F
031C:  MOV     #12,W5
031E:  REPEAT  #3
0320:  MOV     [--W15],[W5--]
0322:  MOV     [--W15],W5
0324:  RETURN  
0326:  MOV     W8,[W15++]
0328:  MOV     #12,W8
032A:  REPEAT  #4
032C:  MOV     [W8++],[W15++]
032E:  CLR     W11
0330:  MUL.UU  W12,#0,W12
0332:  MOV     W3,W8
0334:  MOV     W7,W9
0336:  MOV     #7FF,W10
0338:  BCLR.B  42.0
033A:  BCLR.B  42.1
033C:  ASR     W8,#4,W8
033E:  AND     W10,W8,W8
0340:  CP0     W8
0342:  BRA     Z,426
0344:  BCLR.B  42.0
0346:  BCLR.B  42.1
0348:  ASR     W9,#4,W9
034A:  AND     W10,W9,W9
034C:  CP0     W9
034E:  BRA     Z,426
0350:  ADD     W9,W8,W8
0352:  BTSC    W9.B
0354:  BRA     35E
0356:  SUB     #3FF,W8
0358:  BRA     Z,426
035A:  BRA     NC,426
035C:  BRA     364
035E:  MOV     #401,W10
0360:  ADD.B   W10L,W5L,W5L
0362:  BRA     C,426
0364:  XOR     W3,W7,W13
0366:  BCLR.B  42.0
0368:  BCLR.B  42.1
036A:  AND     #F,W3
036C:  BSET    W3.4
036E:  AND     #F,W7
0370:  BSET    W7.4
0372:  MOV     W8,[W15++]
0374:  MUL.UU  W4,W1,W8
0376:  MUL.UU  W5,W0,W10
0378:  ADD     W8,W10,W10
037A:  ADDC    W9,W11,W11
037C:  ADDC    #0,W12
037E:  MUL.UU  W4,W2,W8
0380:  ADD     W8,W11,W11
0382:  ADDC    W9,W12,W12
0384:  MUL.UU  W5,W1,W8
0386:  CLR     W10
0388:  ADD     W8,W11,W11
038A:  ADDC    W9,W12,W12
038C:  ADDC    #0,W10
038E:  MUL.UU  W6,W0,W8
0390:  ADD     W8,W11,W11
0392:  ADDC    W9,W12,W12
0394:  ADDC    #0,W10
0396:  CLR     W11
0398:  MUL.UU  W4,W3,W8
039A:  ADD     W8,W12,W12
039C:  ADDC    W9,W10,W10
039E:  ADDC    #0,W11
03A0:  MUL.UU  W5,W2,W8
03A2:  ADD     W8,W12,W12
03A4:  ADDC    W9,W10,W10
03A6:  ADDC    #0,W11
03A8:  MUL.UU  W6,W1,W8
03AA:  ADD     W8,W12,W12
03AC:  ADDC    W9,W10,W10
03AE:  ADDC    #0,W11
03B0:  MUL.UU  W7,W0,W8
03B2:  ADD     W8,W12,W12
03B4:  ADDC    W9,W10,W10
03B6:  ADDC    #0,W11
03B8:  MOV     W12,W0
03BA:  CLR     W12
03BC:  MUL.UU  W5,W3,W8
03BE:  ADD     W8,W10,W10
03C0:  ADDC    W9,W11,W11
03C2:  ADDC    #0,W12
03C4:  MUL.UU  W6,W2,W8
03C6:  ADD     W8,W10,W10
03C8:  ADDC    W9,W11,W11
03CA:  ADDC    #0,W12
03CC:  MUL.UU  W6,W3,W8
03CE:  ADD     W8,W11,W11
03D0:  ADDC    W9,W12,W12
03D2:  MUL.UU  W7,W1,W8
03D4:  ADD     W8,W10,W10
03D6:  ADDC    W9,W11,W11
03D8:  ADDC    #0,W12
03DA:  MUL.UU  W7,W2,W8
03DC:  ADD     W8,W11,W11
03DE:  ADDC    W9,W12,W12
03E0:  MUL.UU  W7,W3,W8
03E2:  ADD     W8,W12,W12
03E4:  MOV     W10,W1
03E6:  MOV     W11,W2
03E8:  MOV     W12,W3
03EA:  MOV     #5,W4
03EC:  BCLR.B  42.0
03EE:  RRC     W3,W3
03F0:  RRC     W2,W2
03F2:  RRC     W1,W1
03F4:  RRC     W0,W0
03F6:  DEC     W4,W4
03F8:  BRA     NZ,3EC
03FA:  MOV     [--W15],W8
03FC:  INC     W8,W8
03FE:  IOR      W0,  W1,W6
0400:  BRA     Z,404
0402:  BRA     408
0404:  IOR      W2,  W3,W6
0406:  BRA     Z,418
0408:  BTSC    W3.4
040A:  BRA     418
040C:  BCLR.B  42.0
040E:  RLC     W0,W0
0410:  RLC     W1,W1
0412:  RLC     W2,W2
0414:  RLC     W3,W3
0416:  DEC     W8,W8
0418:  SL      W8,#4,W8
041A:  BCLR    W3.F
041C:  BTSC    W13.F
041E:  BSET    W3.F
0420:  BCLR    W3.4
0422:  XOR     W8,W3,W3
0424:  BRA     42C
0426:  MUL.UU  W0,#0,W0
0428:  MUL.UU  W0,#0,W2
042A:  BRA     42C
042C:  MOV     #1A,W8
042E:  REPEAT  #4
0430:  MOV     [--W15],[W8--]
0432:  MOV     [--W15],W8
0434:  RETURN  
0436:  MOV     W8,[W15++]
0438:  MOV     #12,W8
043A:  REPEAT  #4
043C:  MOV     [W8++],[W15++]
043E:  XOR     W3,W7,W13
0440:  MOV     W3,W8
0442:  MOV     W7,W9
0444:  MOV     #7FF,W10
0446:  BCLR.B  42.0
0448:  BCLR.B  42.1
044A:  ASR     W8,#4,W8
044C:  AND     W10,W8,W8
044E:  CP0     W8
0450:  BRA     Z,52A
0452:  BCLR.B  42.0
0454:  BCLR.B  42.1
0456:  ASR     W9,#4,W9
0458:  AND     W10,W9,W9
045A:  CP0     W9
045C:  BRA     Z,52A
045E:  CLR     W10
0460:  SUB     W8,W9,W12
0462:  BRA     NC,46A
0464:  ADD     #3FF,W12
0466:  BRA     C,52A
0468:  BRA     472
046A:  MOV     #401,W11
046C:  SUB     W12,W11,W12
046E:  BRA     NC,52A
0470:  BRA     Z,52A
0472:  CLR     W8
0474:  CLR     W9
0476:  CLR     W10
0478:  CLR     W11
047A:  AND     #1F,W3
047C:  BSET    W3.4
047E:  AND     #1F,W7
0480:  BSET    W7.4
0482:  MOV     W12,[W15++]
0484:  MOV     #36,W12
0486:  SUB     W0,W4,W0
0488:  SUBB    W1,W5,W1
048A:  SUBB    W2,W6,W2
048C:  SUBB    W3,W7,W3
048E:  BRA     N,494
0490:  BRA     C,49E
0492:  BRA     NZ,4A0
0494:  ADD     W0,W4,W0
0496:  ADDC    W1,W5,W1
0498:  ADDC    W2,W6,W2
049A:  ADDC    W3,W7,W3
049C:  BRA     4A0
049E:  BSET    W8.0
04A0:  DEC     W12,W12
04A2:  BRA     Z,4BA
04A4:  BCLR.B  42.0
04A6:  RLC     W0,W0
04A8:  RLC     W1,W1
04AA:  RLC     W2,W2
04AC:  RLC     W3,W3
04AE:  BCLR.B  42.0
04B0:  RLC     W8,W8
04B2:  RLC     W9,W9
04B4:  RLC     W10,W10
04B6:  RLC     W11,W11
04B8:  BRA     486
04BA:  MOV     [--W15],W12
04BC:  BTSC    W11.5
04BE:  BRA     4C2
04C0:  BRA     4CE
04C2:  BCLR.B  42.0
04C4:  RRC     W11,W11
04C6:  RRC     W10,W10
04C8:  RRC     W9,W9
04CA:  RRC     W8,W8
04CC:  BRA     4D4
04CE:  DEC     W12,W12
04D0:  BCLR.B  42.0
04D2:  BRA     Z,52A
04D4:  BTSC.B  42.0
04D6:  BRA     4EA
04D8:  RLC     W0,W0
04DA:  RLC     W1,W1
04DC:  RLC     W2,W2
04DE:  RLC     W3,W3
04E0:  SUB     W0,W4,W4
04E2:  SUBB    W1,W5,W5
04E4:  SUBB    W2,W6,W6
04E6:  SUBB    W3,W7,W7
04E8:  BRA     NC,514
04EA:  INC     W8,W8
04EC:  BRA     NZ,514
04EE:  INC     W9,W9
04F0:  BRA     NZ,514
04F2:  INC     W10,W10
04F4:  BRA     NZ,514
04F6:  INC     W11,W11
04F8:  BRA     NZ,514
04FA:  INC     W12,W12
04FC:  BRA     Z,52A
04FE:  BRA     514
0500:  DEC     W12,W12
0502:  BRA     Z,52A
0504:  BTSC    W11.4
0506:  BRA     514
0508:  BCLR.B  42.0
050A:  RLC     W8,W8
050C:  RLC     W9,W9
050E:  RLC     W10,W10
0510:  RLC     W11,W11
0512:  BRA     504
0514:  SL      W12,#4,W12
0516:  BCLR.B  42.0
0518:  BCLR    W12.F
051A:  BTSC    W13.F
051C:  BSET    W12.F
051E:  BCLR    W11.4
0520:  XOR     W12,W11,W3
0522:  MOV     W10,W2
0524:  MOV     W9,W1
0526:  MOV     W8,W0
0528:  BRA     534
052A:  MOV     #0,W0
052C:  MOV     #0,W1
052E:  MOV     #0,W2
0530:  MOV     #0,W3
0532:  BRA     534
0534:  MOV     #1A,W8
0536:  REPEAT  #4
0538:  MOV     [--W15],[W8--]
053A:  MOV     [--W15],W8
053C:  RETURN  
053E:  MOV     W5,[W15++]
0540:  MOV     W6,[W15++]
0542:  MOV     W3,W4
0544:  MOV     W3,W6
0546:  BCLR.B  42.0
0548:  ASR     W4,#4,W4
054A:  MOV     #7FF,W5
054C:  AND     W5,W4,W4
054E:  BRA     NZ,556
0550:  MUL.UU  W0,#0,W0
0552:  CLR     W2
0554:  BRA     57C
0556:  SUB     #380,W4
0558:  AND     #F,W3
055A:  MOV     #3,W7
055C:  BCLR.B  42.0
055E:  RLC     W0,W0
0560:  RLC     W1,W1
0562:  RLC     W2,W2
0564:  RLC     W3,W3
0566:  DEC     W7,W7
0568:  BRA     NZ,55C
056A:  MOV     W1,W0
056C:  MOV     W2,W1
056E:  BCLR    W3.7
0570:  SWAP    W4
0572:  BCLR.B  42.0
0574:  RRC     W4,W4
0576:  BTSC    W6.F
0578:  BSET    W4.F
057A:  XOR     W4,W3,W2
057C:  MOV     [--W15],W6
057E:  MOV     [--W15],W5
0580:  RETURN  
0582:  MOV     W5,[W15++]
0584:  MOV     #C,W5
0586:  REPEAT  #3
0588:  MOV     [W5++],[W15++]
058A:  CLR     W9
058C:  MOV     #8000,W8
058E:  BTSC.B  43.0
0590:  XOR     W8,W3,W3
0592:  CP0     W0
0594:  BRA     NZ,59C
0596:  MOV     #7FFF,W10
0598:  AND     W1,W10,W10
059A:  BTSS.B  42.1
059C:  MOV     W1,W10
059E:  XOR     W3,W10,W11
05A0:  MOV     W1,W6
05A2:  MOV     W3,W7
05A4:  MOV     W3,W12
05A6:  BCLR.B  42.1
05A8:  BCLR.B  42.0
05AA:  RLC     W6,W6
05AC:  SWAP    W6
05AE:  AND     #FF,W6
05B0:  CP0     W6
05B2:  BRA     Z,6F6
05B4:  BCLR.B  42.1
05B6:  BCLR.B  42.0
05B8:  RLC     W7,W7
05BA:  SWAP    W7
05BC:  AND     #FF,W7
05BE:  CP0     W7
05C0:  BRA     Z,700
05C2:  BCLR.B  42.1
05C4:  BCLR.B  42.0
05C6:  CP      W7,W6
05C8:  BRA     Z,702
05CA:  BRA     N,712
05CC:  BCLR    W9.0
05CE:  BSET    W9.1
05D0:  SUB     W7,W6,W8
05D2:  MOV     W7,W6
05D4:  AND     #FF,W1
05D6:  BSET    W1.7
05D8:  AND     #FF,W3
05DA:  BSET    W3.7
05DC:  MOV     #28,W7
05DE:  CP      W7,W8
05E0:  BRA     N,604
05E2:  BCLR.B  42.1
05E4:  BCLR.B  42.0
05E6:  RRC     W1,W1
05E8:  RRC     W0,W0
05EA:  DEC     W8,W8
05EC:  BRA     NZ,5E2
05EE:  BRA     60A
05F0:  MOV     #28,W7
05F2:  CP      W7,W8
05F4:  BRA     N,608
05F6:  BCLR.B  42.1
05F8:  BCLR.B  42.0
05FA:  RRC     W3,W3
05FC:  RRC     W2,W2
05FE:  DEC     W8,W8
0600:  BRA     NZ,5F6
0602:  BRA     622
0604:  MOV     W2,W0
0606:  MOV     W3,W1
0608:  BRA     690
060A:  BTSS    W11.F
060C:  BRA     630
060E:  BTSC    W9.4
0610:  MOV     W12,W11
0612:  NEG     W0,W0
0614:  BRA     Z,61A
0616:  COM.B   W1L,W1L
0618:  BRA     61C
061A:  NEG     W1,W1
061C:  BTSC    W9.4
061E:  BRA     676
0620:  BRA     630
0622:  BTSS    W11.F
0624:  BRA     630
0626:  NEG     W2,W2
0628:  BRA     Z,62E
062A:  COM.B   W3L,W3L
062C:  BRA     630
062E:  NEG     W3,W3
0630:  AND     #FF,W5
0632:  BCLR.B  42.1
0634:  BCLR.B  42.0
0636:  ADD     W0,W2,W0
0638:  ADDC.B  W1L,W3L,W1L
063A:  BTSC.B  42.0
063C:  BSET    W9.3
063E:  BTSC    W9.0
0640:  BRA     654
0642:  BTSC    W9.1
0644:  BRA     648
0646:  BRA     65E
0648:  BTSC    W11.F
064A:  BRA     676
064C:  BTSC    W9.3
064E:  BRA     6A2
0650:  BSET    W9.6
0652:  BRA     690
0654:  BTSC    W11.F
0656:  BRA     676
0658:  BTSC    W9.3
065A:  BRA     6A2
065C:  BRA     690
065E:  BCLR    W9.2
0660:  BTSC    W11.F
0662:  BRA     66C
0664:  MOV     W10,W11
0666:  BTSC    W9.3
0668:  BRA     6A2
066A:  BRA     6D8
066C:  BSET    W9.4
066E:  XOR.B   #80,W1L
0670:  BTSC    W1.7
0672:  BRA     60E
0674:  MOV     W10,W11
0676:  AND     #FF,W1
0678:  IOR      W0,  W1,W7
067A:  BRA     Z,690
067C:  BTSC    W1.7
067E:  BRA     690
0680:  BCLR.B  42.1
0682:  BCLR.B  42.0
0684:  RLC     W0,W0
0686:  RLC     W1,W1
0688:  DEC     W6,W6
068A:  BTSC.B  42.1
068C:  BRA     6F0
068E:  BRA     67C
0690:  BTSC    W9.0
0692:  MOV     W10,W11
0694:  BTSC    W9.1
0696:  MOV     W12,W11
0698:  BTSS    W9.5
069A:  BRA     6D0
069C:  BTSC    W10.F
069E:  BSET    W0.8
06A0:  BRA     6D8
06A2:  BSET.B  42.0
06A4:  RRC.B   W1L,W1L
06A6:  RRC     W0,W0
06A8:  BTSC.B  42.0
06AA:  BSET    W9.5
06AC:  INC     W6,W6
06AE:  BRA     Z,6F0
06B0:  BTSS    W9.5
06B2:  BRA     6C4
06B4:  INC     W0,W0
06B6:  BRA     NZ,6C4
06B8:  INC.B   W1L,W1L
06BA:  BRA     NZ,6C4
06BC:  RRC.B   W1L,W1L
06BE:  RRC     W0,W0
06C0:  INC     W6,W6
06C2:  BRA     Z,6F0
06C4:  BTSC    W9.0
06C6:  MOV     W10,W11
06C8:  BTSC    W9.1
06CA:  MOV     W12,W11
06CC:  BTSC.B  42.1
06CE:  BRA     6F0
06D0:  BTSC    W9.6
06D2:  MOV     W10,W11
06D4:  BTSC    W9.7
06D6:  MOV     W12,W11
06D8:  IOR      W0,  W1,W2
06DA:  BRA     Z,722
06DC:  BCLR    W1.7
06DE:  SWAP    W6
06E0:  BCLR.B  42.1
06E2:  BCLR.B  42.0
06E4:  RRC     W6,W6
06E6:  XOR     W6,W1,W1
06E8:  BSET    W1.F
06EA:  BTSS    W11.F
06EC:  BCLR    W1.F
06EE:  BRA     722
06F0:  MOV     #0,W0
06F2:  MOV     #0,W1
06F4:  BRA     722
06F6:  BTSC    W10.F
06F8:  XOR     W8,W3,W3
06FA:  MOV     W2,W0
06FC:  MOV     W3,W1
06FE:  BRA     722
0700:  BRA     722
0702:  AND     #FF,W3
0704:  BSET    W3.7
0706:  AND     #FF,W1
0708:  BSET    W1.7
070A:  BTSC    W11.F
070C:  BCLR    W3.7
070E:  BSET    W9.2
0710:  BRA     622
0712:  SUB     W6,W7,W8
0714:  AND     #FF,W1
0716:  BSET    W1.7
0718:  AND     #FF,W3
071A:  BSET    W3.7
071C:  BCLR    W9.1
071E:  BSET    W9.0
0720:  BRA     5F0
0722:  MOV     #12,W5
0724:  REPEAT  #3
0726:  MOV     [--W15],[W5--]
0728:  MOV     [--W15],W5
072A:  RETURN  
072C:  MOV     W5,[W15++]
072E:  MOV     #C,W5
0730:  REPEAT  #4
0732:  MOV     [W5++],[W15++]
0734:  MOV     W0,W4
0736:  MOV     W1,W5
0738:  MOV     W3,W7
073A:  MOV     W2,W6
073C:  BCLR.B  42.0
073E:  BCLR.B  42.1
0740:  RLC     W1,W1
0742:  SWAP    W1
0744:  AND     #FF,W1
0746:  CP0     W1
0748:  BRA     Z,7E0
074A:  BCLR.B  42.0
074C:  BCLR.B  42.1
074E:  RLC     W3,W3
0750:  SWAP    W3
0752:  AND     #FF,W3
0754:  CP0     W3
0756:  BRA     Z,7E0
0758:  ZE      W0,W0
075A:  ADD.B   W3L,W1L,W0L
075C:  BRA     C,766
075E:  SUB     #7F,W0
0760:  BRA     Z,7E0
0762:  BRA     NC,7E0
0764:  BRA     76A
0766:  ADD.B   #81,W0L
0768:  BRA     C,7E0
076A:  XOR     W5,W7,W10
076C:  BCLR.B  42.0
076E:  BCLR.B  42.1
0770:  AND     #FF,W5
0772:  BSET    W5.7
0774:  BCLR.B  42.0
0776:  AND     #FF,W7
0778:  BSET    W7.7
077A:  MUL.UU  W4,W6,W2
077C:  MUL.UU  W5,W6,W8
077E:  ADDC    W8,W3,W3
0780:  MOV     W9,W1
0782:  BTSC.B  42.0
0784:  INC     W1,W1
0786:  BCLR.B  42.0
0788:  MUL.UU  W7,W4,W8
078A:  ADDC    W8,W3,W3
078C:  ADDC    W9,W1,W1
078E:  MUL.UU  W5,W7,W8
0790:  ADDC    W8,W1,W1
0792:  INC     W0,W0
0794:  CP0     W1
0796:  BTSC.B  42.1
0798:  BRA     79C
079A:  BRA     7A2
079C:  CP0     W3
079E:  BTSC.B  42.1
07A0:  BRA     7AC
07A2:  BTSC    W1.F
07A4:  BRA     7AC
07A6:  RLC     W3,W3
07A8:  RLC     W1,W1
07AA:  DEC     W0,W0
07AC:  MOV     W1,W2
07AE:  BCLR.B  42.0
07B0:  BTSS    W3.7
07B2:  BRA     7C6
07B4:  MOV     #FF00,W7
07B6:  AND     W3,W7,W3
07B8:  ADD     #100,W3
07BA:  ADDC    W2,#0,W2
07BC:  CP0     W2
07BE:  BRA     NZ,7C6
07C0:  CP0     W3
07C2:  BRA     NZ,7C6
07C4:  INC     W0,W0
07C6:  SWAP    W0
07C8:  BCLR.B  42.0
07CA:  BCLR.B  42.1
07CC:  RRC     W0,W1
07CE:  BTSC    W10.F
07D0:  BSET    W1.F
07D2:  BCLR    W2.F
07D4:  SWAP    W2
07D6:  XOR.B   W2L,W1L,W1L
07D8:  SWAP    W3
07DA:  MOV.B   W3L,W2L
07DC:  MOV     W2,W0
07DE:  BRA     7E6
07E0:  MOV     #0,W0
07E2:  MOV     #0,W1
07E4:  BRA     7E6
07E6:  MOV     #14,W5
07E8:  REPEAT  #4
07EA:  MOV     [--W15],[W5--]
07EC:  MOV     [--W15],W5
07EE:  RETURN  
07F0:  MOV     W5,[W15++]
07F2:  MOV     W6,[W15++]
07F4:  MOV     W7,[W15++]
07F6:  XOR     W1,W3,W4
07F8:  BTSS    W4.F
07FA:  BRA     808
07FC:  BCLR.B  42.0
07FE:  BCLR.B  42.1
0800:  BTSS    W1.F
0802:  BRA     850
0804:  BSET.B  42.0
0806:  BRA     850
0808:  MOV     W1,W4
080A:  MOV     W0,W5
080C:  MOV     W3,W6
080E:  MOV     W2,W7
0810:  RLC     W1,W1
0812:  SWAP    W1
0814:  RLC     W3,W3
0816:  SWAP    W3
0818:  SUB.B   W3L,W1L,W1L
081A:  BRA     Z,826
081C:  BTSS    W4.F
081E:  BRA     850
0820:  MOV     #1,W0
0822:  XOR.B   42
0824:  BRA     850
0826:  MOV.B   W4L,W1L
0828:  MOV.B   W6L,W3L
082A:  BCLR    W1.7
082C:  BCLR    W3.7
082E:  SUB.B   W3L,W1L,W1L
0830:  BRA     Z,83C
0832:  BTSS    W4.F
0834:  BRA     850
0836:  MOV     #1,W0
0838:  XOR.B   42
083A:  BRA     850
083C:  SUB     W7,W5,W1
083E:  BRA     Z,84A
0840:  BTSS    W4.F
0842:  BRA     850
0844:  MOV     #1,W0
0846:  XOR.B   42
0848:  BRA     850
084A:  BCLR.B  42.0
084C:  BRA     850
084E:  BRA     850
0850:  MOV     [--W15],W7
0852:  MOV     [--W15],W6
0854:  MOV     [--W15],W5
0856:  RETURN  
*
0FAC:  MOV     W5,[W15++]
0FAE:  MOV     W2,W3
0FB0:  MOV     W2,W5
0FB2:  BCLR.B  42.0
0FB4:  RLC     W3,W3
0FB6:  SWAP    W3
0FB8:  AND     #FF,W3
0FBA:  BRA     NZ,FC2
0FBC:  MUL.UU  W0,#0,W0
0FBE:  MUL.UU  W2,#0,W2
0FC0:  BRA     FEE
0FC2:  ADD     #380,W3
0FC4:  AND     #7F,W2
0FC6:  MOV     #3,W6
0FC8:  CLR     W4
0FCA:  BCLR.B  42.0
0FCC:  RRC     W2,W2
0FCE:  RRC     W1,W1
0FD0:  RRC     W0,W0
0FD2:  BTSC.B  42.0
0FD4:  INC     W4,W4
0FD6:  DEC     W6,W6
0FD8:  BRA     NZ,FCA
0FDA:  BCLR    W2.7
0FDC:  SL      W3,#4,W3
0FDE:  BCLR    W3.F
0FE0:  BTSC    W5.F
0FE2:  BSET    W3.F
0FE4:  XOR     W2,W3,W3
0FE6:  MOV     W1,W2
0FE8:  MOV     W0,W1
0FEA:  ADD     W4,W1,W1
0FEC:  CLR     W0
0FEE:  MOV     [--W15],W5
0FF0:  RETURN  
0FF2:  MOV     W5,[W15++]
0FF4:  MOV     #C,W5
0FF6:  REPEAT  #7
0FF8:  MOV     [W5++],[W15++]
0FFA:  MUL.UU  W6,#0,W6
0FFC:  MUL.UU  W8,#0,W8
0FFE:  MUL.UU  W10,#0,W10
1000:  MUL.UU  W12,#0,W12
1002:  MOV     #E,W8
1004:  MOV     #0,W9
1006:  LNK     #10
1008:  MOV     W12,[W14+W8]
100A:  DEC2    W8,W8
100C:  BRA     NN,1008
100E:  BTSS    W3.F
1010:  BRA     1016
1012:  BSET    W4.6
1014:  DEC.B   0009
1016:  MOV     #7FF0,W5
1018:  AND     W3,W5,W5
101A:  BRA     Z,115C
101C:  AND     W3,#F,W3
101E:  BSET    W3.4
1020:  LSR     W5,#4,W5
1022:  MOV     #3FF,W6
1024:  SUB     W5,W6,W5
1026:  BRA     NC,10DC
1028:  CLR     W8
102A:  MOV     #4,W6
102C:  BCLR.B  42.0
102E:  RLC     W0,W0
1030:  RLC     W1,W1
1032:  RLC     W2,W2
1034:  RLC     W3,W3
1036:  DEC     W6,W6
1038:  BRA     NZ,102C
103A:  CP      W5,#4
103C:  BRA     C,104A
103E:  CP      W5,#3
1040:  BRA     NZ,1154
1042:  LSR     W3,#5,W6
1044:  CP      W6,#A
1046:  BTSS.B  42.0
1048:  BRA     1154
104A:  MOV     #3,W6
104C:  SUB     W5,W6,W5
104E:  INC     W8,W8
1050:  CALL    12F0
1054:  CALL    12D4
1058:  BCLR.B  42.0
105A:  RLC     W0,W0
105C:  RLC     W1,W1
105E:  RLC     W2,W2
1060:  RLC     W3,W3
1062:  CALL    12B0
1066:  MOV     #2,W6
1068:  BCLR.B  42.0
106A:  RRC     W3,W3
106C:  RRC     W2,W2
106E:  RRC     W1,W1
1070:  RRC     W0,W0
1072:  DEC     W6,W6
1074:  BRA     NZ,1068
1076:  CALL    12D4
107A:  MOV     #4,W6
107C:  BCLR.B  42.0
107E:  RRC     W13,W13
1080:  RRC     W12,W12
1082:  RRC     W11,W11
1084:  RRC     W10,W10
1086:  DEC     W6,W6
1088:  BRA     NZ,107C
108A:  CALL    12B0
108E:  CALL    12D4
1092:  MOV     #8,W6
1094:  BCLR.B  42.0
1096:  RRC     W13,W13
1098:  RRC     W12,W12
109A:  RRC     W11,W11
109C:  RRC     W10,W10
109E:  DEC     W6,W6
10A0:  BRA     NZ,1094
10A2:  AND     #FF,W13
10A4:  CALL    12B0
10A8:  CALL    12D4
10AC:  MOV     W11,W10
10AE:  MOV     W12,W11
10B0:  MOV     W13,W12
10B2:  CLR     W13
10B4:  CALL    12B0
10B8:  CALL    12DE
10BC:  BTSC    W3.8
10BE:  BRA     103A
10C0:  CP0     W5
10C2:  BRA     NZ,10CE
10C4:  INC     W0,W0
10C6:  INC     W1,W1
10C8:  INC     W2,W2
10CA:  INC     W3,W3
10CC:  BRA     1154
10CE:  BCLR.B  42.0
10D0:  RLC     W0,W0
10D2:  RLC     W1,W1
10D4:  RLC     W2,W2
10D6:  RLC     W3,W3
10D8:  DEC     W5,W5
10DA:  BRA     103A
10DC:  COM     W5,W5
10DE:  INC     W5,W5
10E0:  MOV     #3FF,W6
10E2:  ADD     W5,W6,W5
10E4:  CLR     W8
10E6:  MOV     #4,W6
10E8:  BCLR.B  42.0
10EA:  RLC     W0,W0
10EC:  RLC     W1,W1
10EE:  RLC     W2,W2
10F0:  RLC     W3,W3
10F2:  DEC     W6,W6
10F4:  BRA     NZ,10E8
10F6:  ADD     W5,#4,W5
10F8:  MOV     #3FF,W6
10FA:  SUB     W5,W6,W5
10FC:  CP      W5,#5
10FE:  BRA     NC,1166
1100:  CALL    12F0
1104:  CALL    12D4
1108:  BCLR.B  42.0
110A:  RLC     W0,W0
110C:  RLC     W1,W1
110E:  RLC     W2,W2
1110:  RLC     W3,W3
1112:  BCLR.B  42.0
1114:  RLC     W0,W0
1116:  RLC     W1,W1
1118:  RLC     W2,W2
111A:  RLC     W3,W3
111C:  CALL    12B0
1120:  CALL    12DE
1124:  BCLR.B  42.0
1126:  RLC     W0,W0
1128:  RLC     W1,W1
112A:  RLC     W2,W2
112C:  RLC     W3,W3
112E:  INC     W8,W8
1130:  MOV     #3,W6
1132:  BCLR.B  42.0
1134:  RRC     W3,W3
1136:  RRC     W2,W2
1138:  RRC     W1,W1
113A:  RRC     W0,W0
113C:  DEC     W6,W6
113E:  BRA     NZ,1132
1140:  SUB     W5,#3,W5
1142:  BTSS    W3.9
1144:  BRA     10FC
1146:  BCLR.B  42.0
1148:  RRC     W3,W3
114A:  RRC     W2,W2
114C:  RRC     W1,W1
114E:  RRC     W0,W0
1150:  DEC     W5,W5
1152:  BRA     10FC
1154:  NEG     W5,W5
1156:  ADD     W5,#3,W5
1158:  MOV     #2B,W6
115A:  BRA     116A
115C:  MUL.UU  W0,#0,W0
115E:  MUL.UU  W2,#0,W2
1160:  CLR     W8
1162:  CLR     W6
1164:  BRA     116A
1166:  DEC     W5,W5
1168:  MOV     #2D,W6
116A:  BTSS    W4.6
116C:  BRA     1182
116E:  MOV     W0,W7
1170:  MOV     W4,[W15++]
1172:  BTSC.B  223.1
1174:  BRA     1172
1176:  MOV     #2D,W4
1178:  MOV     W4,224
117A:  MOV     [--W15],W4
117C:  MOV     W7,W0
117E:  BCLR    W4.6
1180:  BCLR    W4.7
1182:  CLR     W10
1184:  LSR     W3,#5,W9
1186:  CP0     W5
1188:  BRA     Z,1194
118A:  MOV     W5,W11
118C:  BCLR.B  42.0
118E:  RRC     W9,W9
1190:  DEC     W11,W11
1192:  BRA     NZ,118C
1194:  CP.B    W4L,W10L
1196:  BRA     NC,1208
1198:  MOV     W0,W7
119A:  MOV     #30,W0
119C:  ADD     W9,W0,W0
119E:  MOV     W4,[W15++]
11A0:  BTSC.B  223.1
11A2:  BRA     11A0
11A4:  MOV     W0,224
11A6:  MOV     [--W15],W4
11A8:  MOV     W7,W0
11AA:  CP0     W10
11AC:  BRA     NZ,11BE
11AE:  MOV     W0,W7
11B0:  MOV     W4,[W15++]
11B2:  BTSC.B  223.1
11B4:  BRA     11B2
11B6:  MOV     #2E,W4
11B8:  MOV     W4,224
11BA:  MOV     [--W15],W4
11BC:  MOV     W7,W0
11BE:  INC     W10,W10
11C0:  CP0     W5
11C2:  BRA     Z,11CE
11C4:  MOV     W5,W11
11C6:  BCLR.B  42.0
11C8:  RLC     W9,W9
11CA:  DEC     W11,W11
11CC:  BRA     NZ,11C6
11CE:  LSR     W3,#5,W7
11D0:  SUB     W7,W9,W7
11D2:  SL      W7,#5,W7
11D4:  AND     W3,#1F,W3
11D6:  IOR      W7,  W3,W3
11D8:  CALL    12F0
11DC:  CALL    12D4
11E0:  BCLR.B  42.0
11E2:  RLC     W0,W0
11E4:  RLC     W1,W1
11E6:  RLC     W2,W2
11E8:  RLC     W3,W3
11EA:  BCLR.B  42.0
11EC:  RLC     W0,W0
11EE:  RLC     W1,W1
11F0:  RLC     W2,W2
11F2:  RLC     W3,W3
11F4:  CALL    12B0
11F8:  CALL    12DE
11FC:  BCLR.B  42.0
11FE:  RLC     W0,W0
1200:  RLC     W1,W1
1202:  RLC     W2,W2
1204:  RLC     W3,W3
1206:  BRA     1184
1208:  MOV     W0,W7
120A:  MOV     W4,[W15++]
120C:  BTSC.B  223.1
120E:  BRA     120C
1210:  MOV     #45,W4
1212:  MOV     W4,224
1214:  MOV     [--W15],W4
1216:  MOV     W7,W0
1218:  CP0     W6
121A:  BRA     Z,122A
121C:  MOV     W0,W7
121E:  MOV     W6,W0
1220:  MOV     W4,[W15++]
1222:  BTSC.B  223.1
1224:  BRA     1222
1226:  MOV     W0,224
1228:  MOV     [--W15],W4
122A:  CLR     W12
122C:  MOV     W8,W13
122E:  SUB     W13,#A,W13
1230:  BRA     NC,1292
1232:  INC     W12,W12
1234:  SUB     W13,#A,W13
1236:  BRA     C,1232
1238:  ADD     W13,#A,W13
123A:  CP      W12,#A
123C:  BRA     C,125C
123E:  MOV     W0,W7
1240:  MOV     #30,W0
1242:  ADD.B   W0L,W12L,W0L
1244:  MOV     W4,[W15++]
1246:  BTSC.B  223.1
1248:  BRA     1246
124A:  MOV     W0,224
124C:  MOV     #30,W0
124E:  ADD.B   W0L,W13L,W0L
1250:  BTSC.B  223.1
1252:  BRA     1250
1254:  MOV     W0,224
1256:  MOV     [--W15],W4
1258:  MOV     W7,W0
125A:  BRA     1302
125C:  CLR     W11
125E:  SUB     W12,#A,W12
1260:  INC     W11,W11
1262:  SUB.B   W12L,#A,W12L
1264:  BRA     C,1260
1266:  MOV     #30,W0
1268:  ADD.B   W12L,#A,W12L
126A:  MOV     W0,W7
126C:  MOV     #30,W0
126E:  ADD.B   W0L,W11L,W0L
1270:  MOV     W4,[W15++]
1272:  BTSC.B  223.1
1274:  BRA     1272
1276:  MOV     W0,224
1278:  MOV     #30,W0
127A:  ADD.B   W0L,W12L,W0L
127C:  BTSC.B  223.1
127E:  BRA     127C
1280:  MOV     W0,224
1282:  MOV     #30,W0
1284:  ADD.B   W0L,W13L,W0L
1286:  BTSC.B  223.1
1288:  BRA     1286
128A:  MOV     W0,224
128C:  MOV     [--W15],W4
128E:  MOV     W7,W0
1290:  BRA     1302
1292:  ADD.B   W13L,#A,W13L
1294:  MOV     W0,W7
1296:  MOV     W4,[W15++]
1298:  BTSC.B  223.1
129A:  BRA     1298
129C:  MOV     #30,W4
129E:  MOV     W4,224
12A0:  MOV     #30,W0
12A2:  ADD.B   W0L,W13L,W0L
12A4:  BTSC.B  223.1
12A6:  BRA     12A4
12A8:  MOV     W0,224
12AA:  MOV     [--W15],W4
12AC:  MOV     W7,W0
12AE:  BRA     1302
12B0:  ADD     W10,W0,W0
12B2:  BRA     NC,12C0
12B4:  INC     W1,W1
12B6:  BRA     NZ,12C0
12B8:  INC     W2,W2
12BA:  BRA     NZ,12C0
12BC:  INC     W3,W3
12BE:  BRA     NZ,12C0
12C0:  ADD     W11,W1,W1
12C2:  BRA     NC,12CA
12C4:  INC     W2,W2
12C6:  BRA     NZ,12CA
12C8:  INC     W3,W3
12CA:  ADD     W12,W2,W2
12CC:  BTSC.B  42.0
12CE:  INC     W3,W3
12D0:  ADD     W3,W13,W3
12D2:  RETURN  
12D4:  MOV     W3,W13
12D6:  MOV     W2,W12
12D8:  MOV     W1,W11
12DA:  MOV     W0,W10
12DC:  RETURN  
12DE:  MOV     W10,[W14+#8]
12E0:  MOV     W11,[W14+#A]
12E2:  MOV     W12,[W14+#C]
12E4:  MOV     W13,[W14+#E]
12E6:  MOV     [W14],W10
12E8:  MOV     [W14+#2],W11
12EA:  MOV     [W14+#4],W12
12EC:  MOV     [W14+#6],W13
12EE:  RETURN  
12F0:  MOV     W10,[W14]
12F2:  MOV     W11,[W14+#2]
12F4:  MOV     W12,[W14+#4]
12F6:  MOV     W13,[W14+#6]
12F8:  MOV     [W14+#8],W10
12FA:  MOV     [W14+#A],W11
12FC:  MOV     [W14+#C],W12
12FE:  MOV     [W14+#E],W13
1300:  RETURN  
1302:  ULNK    
1304:  MOV     #1A,W5
1306:  REPEAT  #7
1308:  MOV     [--W15],[W5--]
130A:  MOV     [--W15],W5
130C:  RETURN  
130E:  MOV     W5,[W15++]
1310:  MOV     #C,W5
1312:  REPEAT  #3
1314:  MOV     [W5++],[W15++]
1316:  BTSS    W0.F
1318:  BRA     1332
131A:  NEG     W0,W0
131C:  BSET    W4.8
131E:  BTSS    W4.F
1320:  BRA     1332
1322:  MOV     W0,[W15++]
1324:  MOV     #2D,W0
1326:  BTSC.B  223.1
1328:  BRA     1326
132A:  MOV     W0,224
132C:  MOV     [--W15],W0
132E:  BCLR    W4.8
1330:  DEC.B   0008
1332:  CLR     W5
1334:  MOV     W0,W7
1336:  MOV     W4,W9
1338:  BCLR    W4.F
133A:  CP0.B   W4L
133C:  BRA     NZ,134A
133E:  BTSC    W9.F
1340:  BRA     1346
1342:  MOV     #0,W5
1344:  BRA     1364
1346:  MOV     #0,W5
1348:  BRA     1364
134A:  SUB.B   W4L,#6,W5L
134C:  BRA     NC,1362
134E:  MOV     #30,W0
1350:  BTSS    W9.F
1352:  MOV     #20,W0
1354:  BTSC.B  223.1
1356:  BRA     1354
1358:  MOV     W0,224
135A:  DEC     W5,W5
135C:  BRA     NN,1354
135E:  MOV     #5,W5
1360:  BRA     1364
1362:  MOV     W4,W5
1364:  MOV     #6,W4
1366:  BTSC    W5.8
1368:  INC     W4,W4
136A:  BSET    W5.E
136C:  BTSC    W9.F
136E:  BSET    W5.F
1370:  MOV     #2710,W8
1372:  REPEAT  #11
1374:  DIV.U   W7,W8
1376:  CALL    13BA
137A:  MOV     W1,W7
137C:  MOV     #3E8,W8
137E:  REPEAT  #11
1380:  DIV.U   W7,W8
1382:  CALL    13BA
1386:  MOV     W1,W7
1388:  MOV     #64,W8
138A:  REPEAT  #11
138C:  DIV.U   W7,W8
138E:  CALL    13BA
1392:  MOV     W1,W7
1394:  MOV     #A,W8
1396:  REPEAT  #11
1398:  DIV.U   W7,W8
139A:  CALL    13BA
139E:  BTSS    W9.8
13A0:  BRA     13AC
13A2:  MOV     #2D,W0
13A4:  BTSC.B  223.1
13A6:  BRA     13A4
13A8:  MOV     W0,224
13AA:  BCLR    W9.8
13AC:  MOV     #30,W0
13AE:  ADD.B   W1L,W0L,W0L
13B0:  MOV     W0,2A
13B2:  BTSC.B  223.1
13B4:  BRA     13B2
13B6:  MOV     W0,224
13B8:  BRA     13FA
13BA:  MOV     #30,W6
13BC:  CP0     W0
13BE:  BRA     NZ,13DC
13C0:  BTSS    W5.E
13C2:  BRA     13F0
13C4:  DEC     W4,W4
13C6:  CP.B    W4L,W5L
13C8:  BRA     Z,13CE
13CA:  BTSC.B  42.0
13CC:  RETURN  
13CE:  CP0     W0
13D0:  BRA     NZ,13DC
13D2:  BTSS    W5.E
13D4:  BRA     13F0
13D6:  BTSS    W5.F
13D8:  MOV     #20,W6
13DA:  BRA     13F0
13DC:  BCLR    W5.E
13DE:  BTSS    W9.8
13E0:  BRA     13F0
13E2:  MOV     W0,W10
13E4:  MOV     #2D,W0
13E6:  BTSC.B  223.1
13E8:  BRA     13E6
13EA:  MOV     W0,224
13EC:  BCLR    W9.8
13EE:  MOV     W10,W0
13F0:  ADD.B   W6L,W0L,W0L
13F2:  BTSC.B  223.1
13F4:  BRA     13F2
13F6:  MOV     W0,224
13F8:  RETURN  
13FA:  MOV     #12,W5
13FC:  REPEAT  #3
13FE:  MOV     [--W15],[W5--]
1400:  MOV     [--W15],W5
1402:  RETURN  
....................  
.................... #list 
....................  
.................... #device ADC=10 
.................... #include <PID.h> 
.................... /*  
....................  * File:   PID.h 
....................  * Author: Arsapol 
....................  * 
....................  * Created on October 22, 2016, 10:23 PM 
....................  */ 
....................  
.................... #ifndef PID_H 
.................... #define	PID_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
....................     /*typedef struct { 
....................         float error; 
....................  
....................         float integral; 
....................         float derivative; 
....................  
....................         float previous_error; 
....................  
....................         float distance_set; 
....................         float current_distance; 
....................  
....................         float output; 
....................  
....................         float KP; 
....................         float KI; 
....................         float KD; 
....................     } PID; 
....................  
....................     float PID_Calc(PID *pid) { 
....................         pid->error = pid->distance_set - pid->current_distance; 
....................         //PID control 
....................         pid->integral += pid->error; 
....................         pid->derivative = pid->error - pid->previous_error; 
....................  
....................         pid->output = (pid->KP * pid->error) + (pid->KI * pid->integral) + (pid->KD * pid->derivative); 
....................  
....................         pid->previous_error = pid->error; 
....................  
....................         return pid->output; 
....................     }*/ 
....................  
.................... #define PI 3.14159265359 
.................... #define CPR 400.0 
.................... #define Diameter 0.8 //unit centimeter - ****************Need 
.................... #define Position_Per_Pulse (2.0*PI*(Diameter/2.0))/CPR //cm 
.................... #define Speed PI*Diameter/CPR 
....................      
.................... #define CPR_BY_QEI 800.0 
.................... #define Lead_Pitch 2.0 //unit mm 
.................... #define xPOSITION Lead_Pitch/CPR_BY_QEI 
....................  
.................... #define MAX_SPD 180 //cm/s - ***************************Need Test 
.................... #define MAX_CPR MAX_SPD 
....................  
....................     //New 
....................  
....................     typedef struct { 
....................         float dState; // Last position input 
....................         float iState; // Integrator state 
....................         float iMax, iMin; // Maximum and minimum allowable integrator state 
....................         float iGain, // integral gain 
....................         pGain, // proportional gain 
....................         dGain; // derivative gain 
....................     } SPID; 
....................      
....................     void PID_Init(SPID *pid, float Kp, float Ki, float Kd){ 
*
0C08:  MOV     W5,[W15++]
....................         pid->dState = 0; // Last position input 
0C0A:  MOV     #0,W0
0C0C:  ADD     88A,W0
0C0E:  MOV     W0,W5
0C10:  CLR.B   [W5]
0C12:  MOV.B   #0,W0L
0C14:  MOV.B   W0L,[W5+#1]
0C16:  MOV.B   #0,W0L
0C18:  MOV.B   W0L,[W5+#2]
0C1A:  MOV.B   #0,W0L
0C1C:  MOV.B   W0L,[W5+#3]
....................         pid->iState = 0; // Integrator state 
0C1E:  MOV     #4,W0
0C20:  ADD     88A,W0
0C22:  MOV     W0,W5
0C24:  CLR.B   [W5]
0C26:  MOV.B   #0,W0L
0C28:  MOV.B   W0L,[W5+#1]
0C2A:  MOV.B   #0,W0L
0C2C:  MOV.B   W0L,[W5+#2]
0C2E:  MOV.B   #0,W0L
0C30:  MOV.B   W0L,[W5+#3]
....................         pid->iMax = 0; 
0C32:  MOV     #8,W0
0C34:  ADD     88A,W0
0C36:  MOV     W0,W5
0C38:  CLR.B   [W5]
0C3A:  MOV.B   #0,W0L
0C3C:  MOV.B   W0L,[W5+#1]
0C3E:  MOV.B   #0,W0L
0C40:  MOV.B   W0L,[W5+#2]
0C42:  MOV.B   #0,W0L
0C44:  MOV.B   W0L,[W5+#3]
....................         pid->iMin = 0; // Maximum and minimum allowable integrator state 
0C46:  MOV     #C,W0
0C48:  ADD     88A,W0
0C4A:  MOV     W0,W5
0C4C:  CLR.B   [W5]
0C4E:  MOV.B   #0,W0L
0C50:  MOV.B   W0L,[W5+#1]
0C52:  MOV.B   #0,W0L
0C54:  MOV.B   W0L,[W5+#2]
0C56:  MOV.B   #0,W0L
0C58:  MOV.B   W0L,[W5+#3]
....................         pid->iGain = Ki; // integral gain 
0C5A:  MOV     #10,W0
0C5C:  ADD     88A,W0
0C5E:  MOV     W0,W5
0C60:  MOV     #890,W4
0C62:  MOV     [W4++],[W5++]
0C64:  MOV     [W4++],[W5++]
....................         pid->pGain = Kp; // proportional gain 
0C66:  MOV     #14,W0
0C68:  ADD     88A,W0
0C6A:  MOV     W0,W5
0C6C:  MOV     #88C,W4
0C6E:  MOV     [W4++],[W5++]
0C70:  MOV     [W4++],[W5++]
....................         pid->dGain = Kd; // derivative gain 
0C72:  MOV     #18,W0
0C74:  ADD     88A,W0
0C76:  MOV     W0,W5
0C78:  MOV     #894,W4
0C7A:  MOV     [W4++],[W5++]
0C7C:  MOV     [W4++],[W5++]
0C7E:  MOV     [--W15],W5
0C80:  RETURN  
....................     } 
....................  
....................     float UpdatePID(SPID * pid, float error, float position) { 
*
0858:  MOV     W5,[W15++]
085A:  MOV     W6,[W15++]
....................         float pTerm, dTerm, iTerm; 
....................         pTerm = pid->pGain * error; 
085C:  MOV     #14,W0
085E:  ADD     8CE,W0
0860:  MOV     #A,W4
0862:  MOV     [W0++],[W4++]
0864:  MOV     [W0++],[W4++]
0866:  MOV     W5,W0
0868:  MOV     W6,W1
086A:  MOV     8D0,W2
086C:  MOV     8D2,W3
086E:  CALL    72C
0872:  MOV     W0,8D8
0874:  MOV     W1,8DA
....................         // calculate the proportional term 
....................         // calculate the integral state with appropriate limiting 
....................         pid->iState += error; 
0876:  MOV     #4,W0
0878:  ADD     8CE,W0
087A:  MOV     W0,W5
087C:  BCLR.B  43.0
087E:  MOV     [W5],W0
0880:  MOV     [++W5],W1
0882:  MOV     8D0,W2
0884:  MOV     8D2,W3
0886:  CALL    582
088A:  MOV     #0,W4
088C:  MOV     [W4++],[W5++]
088E:  MOV     [W4++],[W5++]
....................         if (pid->iState > pid->iMax) pid->iState = pid->iMax; 
0890:  MOV     #4,W0
0892:  ADD     8CE,W0
0894:  MOV     #A,W4
0896:  MOV     [W0++],[W4++]
0898:  MOV     [W0++],[W4++]
089A:  MOV     #8,W0
089C:  ADD     8CE,W0
089E:  MOV     W0,W4
08A0:  MOV     #0,W3
08A2:  MOV     [W4++],[W3++]
08A4:  MOV     [W4++],[W3++]
08A6:  MOV     W5,W2
08A8:  MOV     W6,W3
08AA:  CALL    7F0
08AE:  BRA     NC,8C0
08B0:  MOV     #4,W0
08B2:  ADD     8CE,W0
08B4:  MOV     W0,W5
08B6:  MOV     #8,W0
08B8:  ADD     8CE,W0
08BA:  MOV     [W0++],[W5++]
08BC:  MOV     [W0++],[W5++]
08BE:  BRA     8F2
....................         else if (pid->iState < pid->iMin) pid->iState = pid->iMin; 
08C0:  MOV     #4,W0
08C2:  ADD     8CE,W0
08C4:  MOV     #A,W4
08C6:  MOV     [W0++],[W4++]
08C8:  MOV     [W0++],[W4++]
08CA:  MOV     #C,W0
08CC:  ADD     8CE,W0
08CE:  MOV     W0,W4
08D0:  MOV     #0,W3
08D2:  MOV     [W4++],[W3++]
08D4:  MOV     [W4++],[W3++]
08D6:  MOV     W0,W2
08D8:  MOV     W1,W3
08DA:  MOV     W5,W0
08DC:  MOV     W6,W1
08DE:  CALL    7F0
08E2:  BRA     NC,8F2
08E4:  MOV     #4,W0
08E6:  ADD     8CE,W0
08E8:  MOV     W0,W5
08EA:  MOV     #C,W0
08EC:  ADD     8CE,W0
08EE:  MOV     [W0++],[W5++]
08F0:  MOV     [W0++],[W5++]
....................         iTerm = pid->iGain * pid->iState; // calculate the integral term 
08F2:  MOV     #10,W0
08F4:  ADD     8CE,W0
08F6:  MOV     #A,W4
08F8:  MOV     [W0++],[W4++]
08FA:  MOV     [W0++],[W4++]
08FC:  MOV     #4,W0
08FE:  ADD     8CE,W0
0900:  MOV     W0,W4
0902:  MOV     #0,W3
0904:  MOV     [W4++],[W3++]
0906:  MOV     [W4++],[W3++]
0908:  MOV     W0,W2
090A:  MOV     W1,W3
090C:  MOV     W5,W0
090E:  MOV     W6,W1
0910:  CALL    72C
0914:  MOV     W0,8E0
0916:  MOV     W1,8E2
....................         dTerm = pid->dGain * (position - pid->dState); 
0918:  MOV     #18,W0
091A:  ADD     8CE,W0
091C:  MOV     #A,W4
091E:  MOV     [W0++],[W4++]
0920:  MOV     [W0++],[W4++]
0922:  MOV     #0,W0
0924:  ADD     8CE,W0
0926:  MOV     W0,W4
0928:  MOV     #0,W3
092A:  MOV     [W4++],[W3++]
092C:  MOV     [W4++],[W3++]
092E:  BSET.B  43.0
0930:  MOV     W0,W2
0932:  MOV     W1,W3
0934:  MOV     8D4,W0
0936:  MOV     8D6,W1
0938:  CALL    582
093C:  MOV     W0,W2
093E:  MOV     W1,W3
0940:  MOV     W5,W0
0942:  MOV     W6,W1
0944:  CALL    72C
0948:  MOV     W0,8DC
094A:  MOV     W1,8DE
....................         pid->dState = position; 
094C:  MOV     #0,W0
094E:  ADD     8CE,W0
0950:  MOV     W0,W5
0952:  MOV     #8D4,W4
0954:  MOV     [W4++],[W5++]
0956:  MOV     [W4++],[W5++]
....................         return pTerm + iTerm - dTerm; 
0958:  BCLR.B  43.0
095A:  MOV     8D8,W0
095C:  MOV     8DA,W1
095E:  MOV     8E0,W2
0960:  MOV     8E2,W3
0962:  CALL    582
0966:  MOV     W0,W5
0968:  MOV     W1,W6
096A:  BSET.B  43.0
096C:  MOV     W5,W0
096E:  MOV     W6,W1
0970:  MOV     8DC,W2
0972:  MOV     8DE,W3
0974:  CALL    582
0978:  MOV.D   W0,W0
097A:  MOV     [--W15],W6
097C:  MOV     [--W15],W5
097E:  RETURN  
....................     } 
....................  
....................     /*typedef struct { 
....................         boolean usingFeedForward; 
....................         boolean inAuto; 
....................  
....................         //Actual tuning parameters used in PID calculation. 
....................         float Kc_; 
....................         float tauR_; 
....................         float tauD_; 
....................  
....................         //Raw tuning parameters. 
....................         float pParam_; 
....................         float iParam_; 
....................         float dParam_; 
....................  
....................         //The point we want to reach. 
....................         float setPoint_; 
....................         //The thing we measure. 
....................         float processVariable_; 
....................         float prevProcessVariable_; 
....................         //The output that affects the process variable. 
....................         float controllerOutput_; 
....................         float prevControllerOutput_; 
....................  
....................         //We work in % for calculations so these will scale from 
....................         //real world values to 0-100% and back again. 
....................         float inMin_; 
....................         float inMax_; 
....................         float inSpan_; 
....................         float outMin_; 
....................         float outMax_; 
....................         float outSpan_; 
....................  
....................         //The accumulated error, i.e. integral. 
....................         float accError_; 
....................         //The controller output bias. 
....................         float bias_; 
....................  
....................         //The interval between samples. 
....................         float tSample_; 
....................  
....................         //Controller output as a real world value. 
....................         volatile float realOutput_; 
....................     } SPID; 
....................  
....................     void setSetPoint(SPID *pid, float sp) { 
....................         pid->setPoint_ = sp; 
....................     } 
....................  
....................     void setProcessValue(SPID *pid, float pv) { 
....................         pid->processVariable_ = pv; 
....................     } 
....................  
....................     void setInputLimits(SPID *pid, float inMin, float inMax) { 
....................  
....................         //Make sure we haven't been given impossible values. 
....................         if (inMin >= inMax) { 
....................             return; 
....................         } 
....................  
....................         //Rescale the working variables to reflect the changes. 
....................         pid->prevProcessVariable_ *= (inMax - inMin) / pid->inSpan_; 
....................         pid->accError_ *= (inMax - inMin) / pid->inSpan_; 
....................  
....................         //Make sure the working variables are within the new limits. 
....................         if (pid->prevProcessVariable_ > 1) { 
....................             pid->prevProcessVariable_ = 1; 
....................         } else if (pid->prevProcessVariable_ < 0) { 
....................             pid->prevProcessVariable_ = 0; 
....................         } 
....................  
....................         pid->inMin_ = inMin; 
....................         pid->inMax_ = inMax; 
....................         pid->inSpan_ = inMax - inMin; 
....................  
....................     } 
....................  
....................     void setOutputLimits(SPID *pid, float outMin, float outMax) { 
....................  
....................         //Make sure we haven't been given impossible values. 
....................         if (outMin >= outMax) { 
....................             return; 
....................         } 
....................  
....................         //Rescale the working variables to reflect the changes. 
....................         pid->prevControllerOutput_ *= (outMax - outMin) / pid->outSpan_; 
....................  
....................         //Make sure the working variables are within the new limits. 
....................         if (pid->prevControllerOutput_ > 1) { 
....................             pid->prevControllerOutput_ = 1; 
....................         } else if (pid->prevControllerOutput_ < 0) { 
....................             pid->prevControllerOutput_ = 0; 
....................         } 
....................  
....................         pid->outMin_ = outMin; 
....................         pid->outMax_ = outMax; 
....................         pid->outSpan_ = outMax - outMin; 
....................  
....................     } 
....................  
....................     void setTunings(SPID *pid, float Kc, float tauI, float tauD) { 
....................  
....................         //Verify that the tunings make sense. 
....................         if (Kc == 0.0 || tauI < 0.0 || tauD < 0.0) { 
....................             return; 
....................         } 
....................  
....................         //Store raw values to hand back to user on request. 
....................         pid->pParam_ = Kc; 
....................         pid->iParam_ = tauI; 
....................         pid->dParam_ = tauD; 
....................  
....................         float tempTauR; 
....................  
....................         if (tauI == 0.0) { 
....................             tempTauR = 0.0; 
....................         } else { 
....................             tempTauR = (1.0 / tauI) * pid->tSample_; 
....................         } 
....................  
....................         //For "bumpless transfer" we need to rescale the accumulated error. 
....................         if (pid->inAuto) { 
....................             if (tempTauR == 0.0) { 
....................                 pid->accError_ = 0.0; 
....................             } else { 
....................                 pid->accError_ *= (pid->Kc_ * pid->tauR_) / (Kc * tempTauR); 
....................             } 
....................         } 
....................  
....................         pid->Kc_ = Kc; 
....................         pid->tauR_ = tempTauR; 
....................         pid->tauD_ = tauD / pid->tSample_; 
....................  
....................     } 
....................  
....................     void PID_Init(SPID *pid, float Kc, float tauI, float tauD, float interval) { 
....................         pid->usingFeedForward = false; 
....................         pid->inAuto = false; 
....................  
....................         //Default the limits to the full range of I/O: 3.3V 
....................         //Make sure to set these to more appropriate limits for 
....................         //your application. 
....................         setInputLimits(&pid, 0.0, 3.3); 
....................         setOutputLimits(&pid, 0.0, 3.3); 
....................  
....................         pid->tSample_ = interval; 
....................  
....................         setTunings(&pid, Kc, tauI, tauD); 
....................  
....................         pid->setPoint_ = 0.0; 
....................         pid->processVariable_ = 0.0; 
....................         pid->prevProcessVariable_ = 0.0; 
....................         pid->controllerOutput_ = 0.0; 
....................         pid->prevControllerOutput_ = 0.0; 
....................  
....................         pid->accError_ = 0.0; 
....................         pid->bias_ = 0.0; 
....................  
....................         pid->realOutput_ = 0.0; 
....................     } 
....................  
....................     float compute(SPID *pid) { 
....................  
....................         //Pull in the input and setpoint, and scale them into percent span. 
....................         float scaledPV = (pid->processVariable_ - pid->inMin_) / pid->inSpan_; 
....................  
....................         if (scaledPV > 1.0) { 
....................             scaledPV = 1.0; 
....................         } else if (scaledPV < 0.0) { 
....................             scaledPV = 0.0; 
....................         } 
....................  
....................         float scaledSP = (pid->setPoint_ - pid->inMin_) / pid->inSpan_; 
....................         if (scaledSP > 1.0) { 
....................             scaledSP = 1; 
....................         } else if (scaledSP < 0.0) { 
....................             scaledSP = 0; 
....................         } 
....................  
....................         float error = scaledSP - scaledPV; 
....................  
....................         //Check and see if the output is pegged at a limit and only 
....................         //integrate if it is not. This is to prevent reset-windup. 
....................         if (!(pid->prevControllerOutput_ >= 1 && error > 0) && !(pid->prevControllerOutput_ <= 0 && error < 0)) { 
....................             pid->accError_ += error; 
....................         } 
....................  
....................         //Compute the current slope of the input signal. 
....................         float dMeas = (scaledPV - pid->prevProcessVariable_) / pid->tSample_; 
....................  
....................         float scaledBias = 0.0; 
....................  
....................         if (pid->usingFeedForward) { 
....................             scaledBias = (pid->bias_ - pid->outMin_) / pid->outSpan_; 
....................         } 
....................  
....................         //Perform the PID calculation. 
....................         pid->controllerOutput_ = scaledBias + pid->Kc_ * (error + (pid->tauR_ * pid->accError_) - (pid->tauD_ * dMeas)); 
....................  
....................         //Make sure the computed output is within output constraints. 
....................         if (pid->controllerOutput_ < 0.0) { 
....................             pid->controllerOutput_ = 0.0; 
....................         } else if (pid->controllerOutput_ > 1.0) { 
....................             pid->controllerOutput_ = 1.0; 
....................         } 
....................  
....................         //Remember this output for the windup check next time. 
....................         pid->prevControllerOutput_ = pid->controllerOutput_; 
....................         //Remember the input for the derivative calculation next time. 
....................         pid->prevProcessVariable_ = scaledPV; 
....................  
....................         //Scale the output from percent span back out to a real world number. 
....................         return ((pid->controllerOutput_ * pid->outSpan_) + pid->outMin_); 
....................  
....................     }*/ 
....................      
....................     //In main 
....................     /*if (sec_flag == TRUE) { 
....................             sec_flag = FALSE; 
....................             seconds++; 
....................             //printf("%d\r\n", seconds); 
....................         } 
....................           now = seconds; 
....................  
....................         if (now - prev >= RATE * 1000) { 
....................             leftPulses = En_x.Pulses * Speed; 
....................             leftVelocity = (leftPulses - leftPrevPulses) / RATE; 
....................             leftPrevPulses = leftPulses; 
....................             setProcessValue(&Motor_X, leftVelocity); 
....................             leftPwmDuty += compute(&Motor_X); 
....................  
....................             if (leftPwmDuty > 1.0) { 
....................                 leftPwmDuty = 1.0; 
....................             } else if (leftPwmDuty < -1.0) { 
....................                 leftPwmDuty = -1.0; 
....................             } 
....................  
....................             //leftMotor = leftPwmDuty; 
....................  
....................             rightPulses = En_y.Pulses * Speed; 
....................             rightVelocity = (rightPulses - rightPrevPulses) / RATE; 
....................             rightPrevPulses = rightPulses; 
....................             setProcessValue(&Motor_Y, rightVelocity); 
....................             rightPwmDuty += compute(&Motor_Y); 
....................  
....................             if (rightPwmDuty > 1.0) { 
....................                 rightPwmDuty = 1.0; 
....................             } else if (rightPwmDuty < -1.0) { 
....................                 rightPwmDuty = -1.0; 
....................             } 
....................  
....................             //rightMotor = rightPwmDuty; 
.................... #ifdef DEBUG 
....................             printf("left,right pulse duty : %f,%f\n", leftPulses, rightPulses); 
....................             //printf("left,right pwm duty : %f,%f\n",leftPwmDuty,rightPwmDuty); 
....................             printf("left,right Velocity : %f,%f\n", leftVelocity, rightVelocity); 
.................... #endif 
....................             if (leftPwmDuty > 0.1) { 
....................                 output_high(MOTOR_X_DIR); //leftDirection = 1; 
....................                 //leftBrake = 0; 
....................                 Control_Motor(DRIVE_MOTOR_X, leftPwmDuty); //leftMotor = leftPwmDuty; 
....................             } else if (leftPwmDuty < -0.1) { 
....................                 output_low(MOTOR_X_DIR); //leftDirection = 0; 
....................                 //leftBrake = 1; 
....................                 Control_Motor(DRIVE_MOTOR_X, (-1) * leftPwmDuty); //leftMotor = (-1) * leftPwmDuty; 
....................             } else { 
....................                 output_low(MOTOR_X_DIR); //leftDirection = 0; 
....................                 //leftBrake = 0; 
....................                 Control_Motor(DRIVE_MOTOR_X, 0); //leftMotor = 0.0; 
....................             } 
....................  
....................             if (rightPwmDuty > 0.1) { 
....................                 output_high(MOTOR_Y_DIR); //rightDirection = 1; 
....................                 //rightBrake = 0; 
....................                 Control_Motor(DRIVE_MOTOR_Y, rightPwmDuty); //rightMotor = rightPwmDuty; 
....................             } else if (rightPwmDuty < -0.1) { 
....................                 output_low(MOTOR_Y_DIR); //rightDirection = 0; 
....................                 //rightBrake = 1; 
....................                 Control_Motor(DRIVE_MOTOR_Y, (-1) * rightPwmDuty); //rightMotor = (-1) * rightPwmDuty; 
....................             } else { 
....................                 output_low(MOTOR_Y_DIR); //rightDirection = 0; 
....................                 //rightBrake = 0; 
....................                 Control_Motor(DRIVE_MOTOR_Y, 0); //rightMotor = 0.0; 
....................             } 
....................  
....................             prev = now; 
....................         }*/ 
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* PID_H */ 
....................  
....................  
.................... #include <Motor.h> 
.................... /*  
....................  * File:   Motor.h 
....................  * Author: Arsapol 
....................  * 
....................  * Created on October 22, 2016, 11:41 PM 
....................  */ 
.................... #ifndef MOTOR_H 
.................... #define	MOTOR_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................      
....................     typedef struct { 
....................         int B_signal; 
....................         int Pulses; 
....................     } Encoder; 
....................      
....................     void Encoder_Init(Encoder *en){ 
*
0BEA:  MOV     W5,[W15++]
....................         en->B_signal = 0; 
0BEC:  MOV     #0,W0
0BEE:  ADD     88A,W0
0BF0:  MOV     W0,W5
0BF2:  CLR.B   [W5]
0BF4:  MOV.B   #0,W0L
0BF6:  MOV.B   W0L,[W5+#1]
....................         en->Pulses = 0; 
0BF8:  MOV     #2,W0
0BFA:  ADD     88A,W0
0BFC:  MOV     W0,W5
0BFE:  CLR.B   [W5]
0C00:  MOV.B   #0,W0L
0C02:  MOV.B   W0L,[W5+#1]
0C04:  MOV     [--W15],W5
0C06:  RETURN  
....................     } 
....................      
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MOTOR_H */ 
....................  
....................  
.................... #include <config.h> 
.................... /*  
....................  * File:   config.h 
....................  * Author: Arsapol 
....................  * 
....................  * Created on October 23, 2016, 2:08 AM 
....................  */ 
....................  
.................... #ifndef CONFIG_H 
.................... #define	CONFIG_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
.................... #define DRIVE_MOTOR_X   1 
.................... #define DRIVE_MOTOR_Y   2 
.................... #define DRIVE_MOTOR_Z   3 
....................  
.................... #define MOTOR_HZ        5 
....................  
.................... #define MOTOR_X_PWM     PIN_B0 
.................... #define MOTOR_Y_PWM     PIN_B1 
.................... #define MOTOR_Z_PWM     PIN_B9 
....................  
.................... #define MOTOR_X_DIR     PIN_B4 
.................... #define MOTOR_Y_DIR     PIN_B5 
.................... #define MOTOR_Z_DIR     PIN_B6 
....................  
.................... #define ENCODER_X_A     0 
.................... #define ENCODER_Y_A     1     
.................... #define ENCODER_X_B     PIN_B3 
.................... #define ENCODER_Y_B     PIN_B2 
....................     //#define ENCODER_Z_B     PIN_B13 
....................  
....................     //#define TIMES_PER_ROUND 5 
....................  
....................     /* 
....................      ****************Note****************** 
....................      * INT0[Ex] - Encoder Axis X 
....................      * INT1[Ex] - Encoder Axis Y 
....................      * INT2[In] - PWM Timer2 
....................      * INT3[Ex] -                                  (deleted) Encoder Axis Z 
....................      * INT4[ ] -  
....................      *  
....................      * PIN_A0  -  
....................      * PIN_A1  -  
....................      * PIN_A2  -  
....................      * PIN_A3  -  
....................      * PIN_A4  -  
....................      * PIN_B0  - [OUT] AN2 : PWM_MOTOR_X 
....................      * PIN_B1  - [OUT] AN3 : PWM_MOTOR_Y 
....................      * PIN_B2  - [IN]  AN5 : B_Y (Encoder signal B) /                                
....................      * PIN_B3  - [IN]  AN5 : B_X (Encoder signal B) / 
....................      * PIN_B4  - [OUT] DIR_X / 
....................      * PIN_B5  - [OUT] DIR_Y / 
....................      * PIN_B6  -                                    
....................      * PIN_B7  - [IN] INT0 : Read Encoder X 
....................      * PIN_B8  - [IN] INT1 : Read Encoder Y  
....................      * PIN_B9  -                                    
....................      * PIN_B10 -  
....................      * PIN_B11 -  
....................      * PIN_B12 - [IN]  AN12 : B_Y (Encoder signal B) / 
....................      * PIN_B13 - RX                                   
....................      * PIN_B14 - TX 
....................      * PIN_B15 -  
....................      * PIN_B16 -  
....................      */ 
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* CONFIG_H */ 
....................  
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h>  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
*
0C82:  MOV     W5,[W15++]
0C84:  MOV     W6,[W15++]
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
0C86:  CLR     892
....................    sign = 0; 
0C88:  CLR     88E
....................    base = 10; 
0C8A:  MOV     #A,W4
0C8C:  MOV     W4,890
....................    result = 0; 
0C8E:  CLR     88C
....................  
....................    if (!s) 
0C90:  CP0     88A
0C92:  BRA     NZ,C98
....................       return 0; 
0C94:  CLR     0
0C96:  BRA     E18
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
0C98:  MOV     892,W0
0C9A:  INC     0892
0C9C:  MOV     W0,W5
0C9E:  MOV     W5,W0
0CA0:  ADD     88A,W0
0CA2:  MOV     894,W4
0CA4:  MOV.B   [W0+#0],W4L
0CA6:  MOV     W4,894
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0CA8:  MOV     894,W4
0CAA:  XOR.B   #2D,W4L
0CAC:  BRA     NZ,CC4
....................    { 
....................       sign = 1;         // Set the sign to negative 
0CAE:  MOV     #1,W4
0CB0:  MOV     W4,88E
....................       c = s[index++]; 
0CB2:  MOV     892,W0
0CB4:  INC     0892
0CB6:  MOV     W0,W5
0CB8:  MOV     W5,W0
0CBA:  ADD     88A,W0
0CBC:  MOV     894,W4
0CBE:  MOV.B   [W0+#0],W4L
0CC0:  MOV     W4,894
....................    } 
0CC2:  BRA     CDA
....................    else if (c == '+') 
0CC4:  MOV     894,W4
0CC6:  XOR.B   #2B,W4L
0CC8:  BRA     NZ,CDA
....................    { 
....................       c = s[index++]; 
0CCA:  MOV     892,W0
0CCC:  INC     0892
0CCE:  MOV     W0,W5
0CD0:  MOV     W5,W0
0CD2:  ADD     88A,W0
0CD4:  MOV     894,W4
0CD6:  MOV.B   [W0+#0],W4L
0CD8:  MOV     W4,894
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0CDA:  MOV     894,W4
0CDC:  MOV     #30,W3
0CDE:  CP.B    W3L,W4L
0CE0:  BRA     GT,E00
0CE2:  MOV     894,W4
0CE4:  MOV     #39,W3
0CE6:  CP.B    W3L,W4L
0CE8:  BRA     LT,E00
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0CEA:  MOV     894,W4
0CEC:  XOR.B   #30,W4L
0CEE:  BRA     NZ,D1A
0CF0:  MOV     892,W0
0CF2:  ADD     88A,W0
0CF4:  MOV.B   [W0],W4L
0CF6:  XOR.B   #78,W4L
0CF8:  BRA     Z,D04
0CFA:  MOV     892,W0
0CFC:  ADD     88A,W0
0CFE:  MOV.B   [W0],W4L
0D00:  XOR.B   #58,W4L
0D02:  BRA     NZ,D1A
....................       { 
....................          base = 16; 
0D04:  MOV     #10,W4
0D06:  MOV     W4,890
....................          index++; 
0D08:  INC     0892
....................          c = s[index++]; 
0D0A:  MOV     892,W0
0D0C:  INC     0892
0D0E:  MOV     W0,W5
0D10:  MOV     W5,W0
0D12:  ADD     88A,W0
0D14:  MOV     894,W4
0D16:  MOV.B   [W0+#0],W4L
0D18:  MOV     W4,894
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0D1A:  MOV     890,W4
0D1C:  CP      W4,#A
0D1E:  BRA     NZ,D58
....................       { 
....................          while (c >= '0' && c <= '9') 
0D20:  MOV     894,W4
0D22:  MOV     #30,W3
0D24:  CP.B    W3L,W4L
0D26:  BRA     GT,D56
0D28:  MOV     894,W4
0D2A:  MOV     #39,W3
0D2C:  CP.B    W3L,W4L
0D2E:  BRA     LT,D56
....................          { 
....................             result = 10*result + (c - '0'); 
0D30:  MOV     88C,W4
0D32:  MUL.UU  W4,#A,W0
0D34:  MOV     W0,W5
0D36:  MOV     894,W4
0D38:  SUB.B   #30,W4L
0D3A:  MOV.B   W4L,W0L
0D3C:  MOV.B   W0L,0
0D3E:  SE      W0,W0
0D40:  ADD     W0,W5,W0
0D42:  MOV     W0,88C
....................             c = s[index++]; 
0D44:  MOV     892,W0
0D46:  INC     0892
0D48:  MOV     W0,W5
0D4A:  MOV     W5,W0
0D4C:  ADD     88A,W0
0D4E:  MOV     894,W4
0D50:  MOV.B   [W0+#0],W4L
0D52:  MOV     W4,894
0D54:  BRA     D20
....................          } 
....................       } 
0D56:  BRA     E00
....................       else if (base == 16)    // The number is a hexa number 
0D58:  MOV     890,W4
0D5A:  CP      W4,#10
0D5C:  BRA     NZ,E00
....................       { 
....................          c = toupper(c); 
0D5E:  MOV     894,W4
0D60:  MOV     #61,W3
0D62:  CP.B    W3L,W4L
0D64:  BRA     GTU,D74
0D66:  MOV     894,W4
0D68:  MOV     #7A,W3
0D6A:  CP.B    W3L,W4L
0D6C:  BRA     NC,D74
0D6E:  MOV.B   894,W0L
0D70:  AND.B   #DF,W0L
0D72:  BRA     D76
0D74:  MOV.B   894,W0L
0D76:  MOV.B   W0L,894
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
0D78:  MOV     894,W4
0D7A:  MOV     #30,W3
0D7C:  CP.B    W3L,W4L
0D7E:  BRA     GT,D8A
0D80:  MOV     894,W4
0D82:  MOV     #39,W3
0D84:  CP.B    W3L,W4L
0D86:  BRA     LT,D8A
0D88:  BRA     D9A
0D8A:  MOV     894,W4
0D8C:  MOV     #41,W3
0D8E:  CP.B    W3L,W4L
0D90:  BRA     GT,E00
0D92:  MOV     894,W4
0D94:  MOV     #46,W3
0D96:  CP.B    W3L,W4L
0D98:  BRA     LT,E00
....................          { 
....................             if (c >= '0' && c <= '9') 
0D9A:  MOV     894,W4
0D9C:  MOV     #30,W3
0D9E:  CP.B    W3L,W4L
0DA0:  BRA     GT,DBE
0DA2:  MOV     894,W4
0DA4:  MOV     #39,W3
0DA6:  CP.B    W3L,W4L
0DA8:  BRA     LT,DBE
....................                result = (result << 4) + (c - '0'); 
0DAA:  MOV     88C,W5
0DAC:  SL      W5,#4,W5
0DAE:  MOV     894,W4
0DB0:  SUB.B   #30,W4L
0DB2:  MOV.B   W4L,W0L
0DB4:  MOV.B   W0L,0
0DB6:  SE      W0,W0
0DB8:  ADD     W0,W5,W0
0DBA:  MOV     W0,88C
0DBC:  BRA     DD4
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0DBE:  MOV     88C,W5
0DC0:  SL      W5,#4,W5
0DC2:  MOV     894,W4
0DC4:  SUB.B   #41,W4L
0DC6:  MOV.B   W4L,W0L
0DC8:  MOV.B   W0L,0
0DCA:  ZE      W0,W0
0DCC:  CLR.B   1
0DCE:  ADD     W0,#A,W0
0DD0:  ADD     W0,W5,W0
0DD2:  MOV     W0,88C
....................  
....................             c = s[index++]; 
0DD4:  MOV     892,W0
0DD6:  INC     0892
0DD8:  MOV     W0,W5
0DDA:  MOV     W5,W0
0DDC:  ADD     88A,W0
0DDE:  MOV     894,W4
0DE0:  MOV.B   [W0+#0],W4L
0DE2:  MOV     W4,894
....................             c = toupper(c); 
0DE4:  MOV     894,W4
0DE6:  MOV     #61,W3
0DE8:  CP.B    W3L,W4L
0DEA:  BRA     GTU,DFA
0DEC:  MOV     894,W4
0DEE:  MOV     #7A,W3
0DF0:  CP.B    W3L,W4L
0DF2:  BRA     NC,DFA
0DF4:  MOV.B   894,W0L
0DF6:  AND.B   #DF,W0L
0DF8:  BRA     DFC
0DFA:  MOV.B   894,W0L
0DFC:  MOV.B   W0L,894
0DFE:  BRA     D78
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0E00:  MOV     88E,W4
0E02:  CP      W4,#1
0E04:  BRA     NZ,E14
0E06:  MOV     890,W4
0E08:  CP      W4,#A
0E0A:  BRA     NZ,E14
....................        result = -result; 
0E0C:  MOV     #0,W4
0E0E:  MOV     88C,W3
0E10:  SUB     W4,W3,W0
0E12:  MOV     W0,88C
....................  
....................    return(result); 
0E14:  PUSH    88C
0E16:  POP     0
0E18:  MOV     [--W15],W6
0E1A:  MOV     [--W15],W5
0E1C:  RETURN  
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #fuses FRC_PLL 
.................... #use delay (clock = 32000000) 
.................... //#use delay (clock = 16000000) For Use in Hardware 
....................  
.................... #PIN_SELECT U1RX = PIN_B12 
.................... #PIN_SELECT U1TX = PIN_B13 
.................... #use rs232(baud=9600, UART1) 
....................  
.................... #use fixed_io(b_outputs= MOTOR_X_DIR, MOTOR_Y_DIR) //DIR x,y 
....................  
.................... #PIN_SELECT OC1 = MOTOR_X_PWM 
.................... #PIN_SELECT OC2 = MOTOR_Y_PWM 
.................... #PIN_SELECT OC3 = MOTOR_Z_PWM 
.................... #PIN_SELECT INT1 = PIN_B8 //Encoder Y Axis - X is INT0 
....................  
.................... #define RATE  0.1 
.................... #define Kc   0.5 
.................... #define Ti    0.0 
.................... #define Td    0.05 
.................... SPID Motor_X, Motor_Y; 
.................... Encoder En_x, En_y; 
.................... float plantCommand[2] = {0}, position[2] = {0}, drive[2] = {0}; //plantCommand = goal position - x,y 
....................  
.................... int Z_Position = 0; 
....................  
.................... char SM_Buffer[20]; 
.................... int SM_Index = 0; 
.................... float data[2] = {0}; 
.................... int SM_Id = 1; 
.................... boolean isX = FALSE; 
.................... boolean state = FALSE; 
....................  
.................... void SM_RxD(char c) { 
*
0214:  MOV     W5,[W15++]
....................     switch (SM_Id) { 
0216:  MOV     87E,W0
0218:  XOR     #1,W0
021A:  BRA     Z,222
021C:  XOR     #3,W0
021E:  BRA     Z,242
0220:  BRA     266
....................         case 1: 
....................             if (c == ':') { //X data 
0222:  MOV     8CA,W4
0224:  XOR.B   #3A,W4L
0226:  BRA     NZ,232
....................                 isX = TRUE; 
0228:  BSET.B  880.0
....................                 SM_Index = 0; 
022A:  CLR     874
....................                 SM_Id = 2; 
022C:  MOV     #2,W4
022E:  MOV     W4,87E
....................             } else if (c == '!') { //Y data 
0230:  BRA     23E
0232:  MOV     8CA,W4
0234:  XOR.B   #21,W4L
0236:  BRA     NZ,23E
....................                 isX = FALSE; 
0238:  BCLR.B  880.0
....................                 SM_Id = 2; 
023A:  MOV     #2,W4
023C:  MOV     W4,87E
....................             } 
....................             SM_Index = 0; 
023E:  CLR     874
....................             break; 
0240:  BRA     266
....................  
....................         case 2: 
....................             if (c == '#') { 
0242:  MOV     8CA,W4
0244:  XOR.B   #23,W4L
0246:  BRA     NZ,258
....................                 SM_Buffer[SM_Index] = '\0'; 
0248:  MOV     #860,W4
024A:  MOV     874,W3
024C:  ADD     W3,W4,W5
024E:  CLR.B   [W5]
....................                 state = TRUE; 
0250:  BSET.B  880.1
....................                 SM_Id = 1; 
0252:  MOV     #1,W4
0254:  MOV     W4,87E
....................             } else { 
0256:  BRA     264
....................                 SM_Buffer[SM_Index] = c; 
0258:  MOV     #860,W4
025A:  MOV     874,W3
025C:  ADD     W3,W4,W5
025E:  MOV     8CA,W0
0260:  MOV.B   W0L,[W5+#0]
....................                 SM_Index++; 
0262:  INC     0874
....................             } 
....................             break; 
0264:  BRA     266
....................     } 
0266:  MOV     [--W15],W5
0268:  RETURN  
.................... } 
....................  
.................... #INT_RDA 
....................  
.................... void UART1_Isr() { 
026A:  PUSH    42
026C:  PUSH    36
026E:  PUSH    32
0270:  MOV     W0,[W15++]
0272:  MOV     #2,W0
0274:  REPEAT  #C
0276:  MOV     [W0++],[W15++]
0278:  BTSS.B  222.0
027A:  BRA     278
027C:  MOV     226,W0
027E:  MOV.B   W0L,8C8
....................     char c = getc(); 
....................     SM_RxD(c); 
0280:  MOV.B   8C8,W0L
0282:  MOV.B   W0L,8CA
0284:  CALL    214
0288:  BCLR.B  85.3
028A:  MOV     #1A,W0
028C:  REPEAT  #C
028E:  MOV     [--W15],[W0--]
0290:  MOV     [--W15],W0
0292:  POP     32
0294:  POP     36
0296:  POP     42
0298:  RETFIE  
.................... } 
....................  
.................... void Change_ADC_Read_Channel(int channel) { 
....................     set_adc_channel(channel); 
*
0BCA:  PUSH    88A
0BCC:  POP     328
....................     delay_us(10); 
0BCE:  REPEAT  #9E
0BD0:  NOP     
0BD2:  RETURN  
.................... } 
....................  
.................... void Init_ADC() { 
....................     setup_adc_ports(sAN0, VSS_VDD); 
0BD4:  MOV     #FFFE,W4
0BD6:  MOV     W4,32C
0BD8:  CLR     322
....................     setup_adc(ADC_CLOCK_DIV_32); 
0BDA:  MOV     #1F1F,W4
0BDC:  MOV     W4,324
0BDE:  MOV     #80E0,W4
0BE0:  MOV     W4,320
....................     Change_ADC_Read_Channel(0); 
0BE2:  CLR     88A
0BE4:  CALL    BCA
0BE8:  RETURN  
.................... } 
....................  
.................... void Control_Motor(int motor_num, float speed_velo) { 
....................     if (motor_num == DRIVE_MOTOR_X) { 
*
0980:  MOV     8C0,W4
0982:  CP      W4,#1
0984:  BRA     NZ,9AA
....................         if (speed_velo >= 0) output_high(MOTOR_X_DIR); 
0986:  MOV     #0,W0
0988:  MOV     #0,W1
098A:  MOV     8C2,W2
098C:  MOV     8C4,W3
098E:  CALL    7F0
0992:  BRA     C,996
0994:  BRA     NZ,99E
0996:  MOV     #FFCF,W4
0998:  MOV     W4,2C8
099A:  BSET.B  2CC.4
099C:  BRA     9A4
....................         else output_low(MOTOR_X_DIR); 
099E:  MOV     #FFCF,W4
09A0:  MOV     W4,2C8
09A2:  BCLR.B  2CC.4
....................         set_pwm_duty(DRIVE_MOTOR_X, speed_velo); 
09A4:  PUSH    8C2
09A6:  POP     180
....................     } else if (motor_num == DRIVE_MOTOR_Y) { 
09A8:  BRA     9FC
09AA:  MOV     8C0,W4
09AC:  CP      W4,#2
09AE:  BRA     NZ,9D4
....................         if (speed_velo >= 0) output_high(MOTOR_Y_DIR); 
09B0:  MOV     #0,W0
09B2:  MOV     #0,W1
09B4:  MOV     8C2,W2
09B6:  MOV     8C4,W3
09B8:  CALL    7F0
09BC:  BRA     C,9C0
09BE:  BRA     NZ,9C8
09C0:  MOV     #FFCF,W4
09C2:  MOV     W4,2C8
09C4:  BSET.B  2CC.5
09C6:  BRA     9CE
....................         else output_low(MOTOR_Y_DIR); 
09C8:  MOV     #FFCF,W4
09CA:  MOV     W4,2C8
09CC:  BCLR.B  2CC.5
....................         set_pwm_duty(DRIVE_MOTOR_Y, speed_velo); 
09CE:  PUSH    8C2
09D0:  POP     186
....................     } else if (motor_num == DRIVE_MOTOR_Z) { 
09D2:  BRA     9FC
09D4:  MOV     8C0,W4
09D6:  CP      W4,#3
09D8:  BRA     NZ,9FC
....................         if (speed_velo >= 0) output_high(MOTOR_Z_DIR); 
09DA:  MOV     #0,W0
09DC:  MOV     #0,W1
09DE:  MOV     8C2,W2
09E0:  MOV     8C4,W3
09E2:  CALL    7F0
09E6:  BRA     C,9EA
09E8:  BRA     NZ,9F2
09EA:  MOV     #FFCF,W4
09EC:  MOV     W4,2C8
09EE:  BSET.B  2CC.6
09F0:  BRA     9F8
....................         else output_low(MOTOR_Z_DIR); 
09F2:  MOV     #FFCF,W4
09F4:  MOV     W4,2C8
09F6:  BCLR.B  2CC.6
....................         set_pwm_duty(DRIVE_MOTOR_Z, speed_velo); 
09F8:  PUSH    8C2
09FA:  POP     18C
....................     } 
09FC:  RETURN  
.................... } 
....................  
.................... boolean Encoder_Trig_State[2] = {FALSE}; 
....................  
.................... void Encoder_Trig_Change(int num_interrupt) { //Add QEI to encoder ==> CPR*2 so CPR = 400*2 = 800 
*
029A:  MOV     W5,[W15++]
....................     if (num_interrupt == ENCODER_X_A) { 
029C:  CP0     8C6
029E:  BRA     NZ,2B0
....................         //enable_interrupts(INT_EXT0); 
....................         if (Encoder_Trig_State[0] == FALSE) { 
02A0:  BTSC.B  881.0
02A2:  BRA     2AA
....................             ext_int_edge(ENCODER_X_A, L_TO_H); 
02A4:  BCLR.B  82.0
....................             Encoder_Trig_State[0] = TRUE; 
02A6:  BSET.B  881.0
....................         } else { 
02A8:  BRA     2AE
....................             ext_int_edge(ENCODER_X_A, H_TO_L); 
02AA:  BSET.B  82.0
....................             Encoder_Trig_State[0] = FALSE; 
02AC:  BCLR.B  881.0
....................         } 
....................  
....................     } else { 
02AE:  BRA     2BE
....................         //enable_interrupts(INT_EXT1); 
....................         if (Encoder_Trig_State[1] == FALSE) { 
02B0:  BTSC.B  881.1
02B2:  BRA     2BA
....................             ext_int_edge(ENCODER_Y_A, L_TO_H); 
02B4:  BCLR.B  82.1
....................             Encoder_Trig_State[1] = TRUE; 
02B6:  BSET.B  881.1
....................         } else { 
02B8:  BRA     2BE
....................             ext_int_edge(ENCODER_Y_A, H_TO_L); 
02BA:  BSET.B  82.1
....................             Encoder_Trig_State[1] = FALSE; 
02BC:  BCLR.B  881.1
....................         } 
....................     } 
02BE:  MOV     [--W15],W5
02C0:  RETURN  
.................... } 
....................  
.................... #INT_EXT0 
....................  
.................... void INT_EXT_INPUT0(void) { //X Axis 
*
09FE:  PUSH    42
0A00:  PUSH    36
0A02:  PUSH    32
0A04:  MOV     W0,[W15++]
0A06:  MOV     #2,W0
0A08:  REPEAT  #C
0A0A:  MOV     [W0++],[W15++]
....................     //Read Pulse from Encoder and compare pulse A and B 
....................     En_x.B_signal = input(ENCODER_X_B); 
0A0C:  MOV     #FFCF,W4
0A0E:  MOV     W4,2C8
0A10:  CLR     83E
0A12:  BTSC.B  2CA.3
0A14:  INC     083E
....................     if (En_x.B_signal == 0) { 
0A16:  CP0     83E
0A18:  BRA     NZ,A26
....................         if (Encoder_Trig_State[0] == FALSE) En_x.Pulses++; 
0A1A:  BTSC.B  881.0
0A1C:  BRA     A22
0A1E:  INC     0840
0A20:  BRA     A24
....................         else En_x.Pulses--; 
0A22:  DEC     0840
....................     } else { 
0A24:  BRA     A30
....................         if(Encoder_Trig_State[0] == FALSE) En_x.Pulses--; 
0A26:  BTSC.B  881.0
0A28:  BRA     A2E
0A2A:  DEC     0840
0A2C:  BRA     A30
....................         else En_x.Pulses++; 
0A2E:  INC     0840
....................     } 
....................  
....................     Encoder_Trig_Change(ENCODER_X_A); 
0A30:  CLR     8C6
0A32:  CALL    29A
....................  
....................     position[0] = En_x.Pulses * xPOSITION; 
0A36:  MOV     840,W0
0A38:  CLR     W3
0A3A:  BTSC    W0.F
0A3C:  SETM    W3
0A3E:  MOV     W3,W1
0A40:  MOV     W3,W2
0A42:  CALL    2C2
0A46:  MOV     #0,W4
0A48:  MOV     #0,W5
0A4A:  MOV     #0,W6
0A4C:  MOV     #4000,W7
0A4E:  CALL    326
0A52:  MOV     W0,W5
0A54:  MOV     W1,W6
0A56:  MOV     W2,W7
0A58:  MOV     W3,W8
0A5A:  MOV     W5,[W15++]
0A5C:  MOV     W6,[W15++]
0A5E:  MOV     W7,[W15++]
0A60:  MOV     W5,W0
0A62:  MOV     W6,W1
0A64:  MOV     W7,W2
0A66:  MOV     W8,W3
0A68:  MOV     #0,W4
0A6A:  MOV     #0,W5
0A6C:  MOV     #0,W6
0A6E:  MOV     #4089,W7
0A70:  CALL    436
0A74:  MOV     [--W15],W7
0A76:  MOV     [--W15],W6
0A78:  MOV     [--W15],W5
0A7A:  CALL    53E
0A7E:  MOV     W1,84E
0A80:  MOV     W2,850
....................     drive[0] = UpdatePID(&Motor_X, (plantCommand[0] - position[0]), position[0]); 
0A82:  BSET.B  43.0
0A84:  MOV     846,W0
0A86:  MOV     848,W1
0A88:  MOV     84E,W2
0A8A:  MOV     850,W3
0A8C:  CALL    582
0A90:  MOV     W0,W5
0A92:  MOV     W1,W6
0A94:  MOV     #806,W4
0A96:  MOV     W4,8CE
0A98:  MOV     W5,8D0
0A9A:  MOV     W6,8D2
0A9C:  PUSH    84E
0A9E:  POP     8D4
0AA0:  PUSH    850
0AA2:  POP     8D6
0AA4:  CALL    858
0AA8:  MOV     W0,856
0AAA:  MOV     W1,858
....................     Control_Motor(DRIVE_MOTOR_X, drive[0]); 
0AAC:  MOV     #1,W4
0AAE:  MOV     W4,8C0
0AB0:  PUSH    856
0AB2:  POP     8C2
0AB4:  PUSH    858
0AB6:  POP     8C4
0AB8:  CALL    980
.................... } 
....................  
0ABC:  BCLR.B  84.0
0ABE:  MOV     #1A,W0
0AC0:  REPEAT  #C
0AC2:  MOV     [--W15],[W0--]
0AC4:  MOV     [--W15],W0
0AC6:  POP     32
0AC8:  POP     36
0ACA:  POP     42
0ACC:  RETFIE  
.................... #INT_EXT1 
....................  
.................... void INT_EXT_INPUT1(void) { //Y Axis 
0ACE:  PUSH    42
0AD0:  PUSH    36
0AD2:  PUSH    32
0AD4:  MOV     W0,[W15++]
0AD6:  MOV     #2,W0
0AD8:  REPEAT  #C
0ADA:  MOV     [W0++],[W15++]
....................     //Read Pulse from Encoder and compare pulse A and B  
....................     En_y.B_signal = input(ENCODER_Y_B); 
0ADC:  MOV     #FFCF,W4
0ADE:  MOV     W4,2C8
0AE0:  CLR     842
0AE2:  BTSC.B  2CA.2
0AE4:  INC     0842
....................     if (En_y.B_signal == 0) { 
0AE6:  CP0     842
0AE8:  BRA     NZ,AF6
....................         if (Encoder_Trig_State[1] == FALSE) En_y.Pulses++; 
0AEA:  BTSC.B  881.1
0AEC:  BRA     AF2
0AEE:  INC     0844
0AF0:  BRA     AF4
....................         else En_y.Pulses--; 
0AF2:  DEC     0844
....................     } else { 
0AF4:  BRA     B00
....................         if(Encoder_Trig_State[1] == FALSE) En_y.Pulses--; 
0AF6:  BTSC.B  881.1
0AF8:  BRA     AFE
0AFA:  DEC     0844
0AFC:  BRA     B00
....................         else En_y.Pulses++; 
0AFE:  INC     0844
....................     } 
....................  
....................     Encoder_Trig_Change(ENCODER_Y_A); 
0B00:  MOV     #1,W4
0B02:  MOV     W4,8C6
0B04:  CALL    29A
....................  
....................     position[1] = En_y.Pulses * xPOSITION; 
0B08:  MOV     844,W0
0B0A:  CLR     W3
0B0C:  BTSC    W0.F
0B0E:  SETM    W3
0B10:  MOV     W3,W1
0B12:  MOV     W3,W2
0B14:  CALL    2C2
0B18:  MOV     #0,W4
0B1A:  MOV     #0,W5
0B1C:  MOV     #0,W6
0B1E:  MOV     #4000,W7
0B20:  CALL    326
0B24:  MOV     W0,W5
0B26:  MOV     W1,W6
0B28:  MOV     W2,W7
0B2A:  MOV     W3,W8
0B2C:  MOV     W5,[W15++]
0B2E:  MOV     W6,[W15++]
0B30:  MOV     W7,[W15++]
0B32:  MOV     W5,W0
0B34:  MOV     W6,W1
0B36:  MOV     W7,W2
0B38:  MOV     W8,W3
0B3A:  MOV     #0,W4
0B3C:  MOV     #0,W5
0B3E:  MOV     #0,W6
0B40:  MOV     #4089,W7
0B42:  CALL    436
0B46:  MOV     [--W15],W7
0B48:  MOV     [--W15],W6
0B4A:  MOV     [--W15],W5
0B4C:  CALL    53E
0B50:  MOV     W1,852
0B52:  MOV     W2,854
....................     drive[1] = UpdatePID(&Motor_Y, (plantCommand[1] - position[1]), position[1]); 
0B54:  BSET.B  43.0
0B56:  MOV     84A,W0
0B58:  MOV     84C,W1
0B5A:  MOV     852,W2
0B5C:  MOV     854,W3
0B5E:  CALL    582
0B62:  MOV     W0,W5
0B64:  MOV     W1,W6
0B66:  MOV     #822,W4
0B68:  MOV     W4,8CE
0B6A:  MOV     W5,8D0
0B6C:  MOV     W6,8D2
0B6E:  PUSH    852
0B70:  POP     8D4
0B72:  PUSH    854
0B74:  POP     8D6
0B76:  CALL    858
0B7A:  MOV     W0,85A
0B7C:  MOV     W1,85C
....................     Control_Motor(DRIVE_MOTOR_Y, drive[1]); 
0B7E:  MOV     #2,W4
0B80:  MOV     W4,8C0
0B82:  PUSH    85A
0B84:  POP     8C2
0B86:  PUSH    85C
0B88:  POP     8C4
0B8A:  CALL    980
0B8E:  BCLR.B  86.4
0B90:  MOV     #1A,W0
0B92:  REPEAT  #C
0B94:  MOV     [--W15],[W0--]
0B96:  MOV     [--W15],W0
0B98:  POP     32
0B9A:  POP     36
0B9C:  POP     42
0B9E:  RETFIE  
.................... } 
....................  
.................... void Init_Interrupts() { 
....................     enable_interrupts(INT_EXT0); 
0BA0:  BSET.B  94.0
....................     ext_int_edge(ENCODER_X_A, L_TO_H); // Rising Edge 
0BA2:  BCLR.B  82.0
....................     enable_interrupts(INT_EXT1); 
0BA4:  BSET.B  96.4
....................     ext_int_edge(ENCODER_Y_A, L_TO_H); // Rising Edge 
0BA6:  BCLR.B  82.1
....................     enable_interrupts(INT_RDA); 
0BA8:  BSET.B  95.3
0BAA:  RETURN  
.................... } 
....................  
.................... void Init_MotorPWM() { 
....................     setup_timer3(TMR_INTERNAL | TMR_DIV_BY_64, MOTOR_HZ); 
0BAC:  CLR     112
0BAE:  MOV     #5,W4
0BB0:  MOV     W4,10E
0BB2:  MOV     #8020,W4
0BB4:  MOV     W4,112
....................     setup_compare(DRIVE_MOTOR_X, COMPARE_PWM | COMPARE_TIMER3); 
0BB6:  MOV     #E,W4
0BB8:  MOV     W4,184
....................     set_pwm_duty(DRIVE_MOTOR_X, 0); 
0BBA:  CLR     180
....................     setup_compare(DRIVE_MOTOR_Y, COMPARE_PWM | COMPARE_TIMER3); 
0BBC:  MOV     #E,W4
0BBE:  MOV     W4,18A
....................     set_pwm_duty(DRIVE_MOTOR_Y, 0); 
0BC0:  CLR     186
....................     setup_compare(DRIVE_MOTOR_Z, COMPARE_PWM | COMPARE_TIMER3); 
0BC2:  MOV     #E,W4
0BC4:  MOV     W4,190
....................     set_pwm_duty(DRIVE_MOTOR_Z, 0); 
0BC6:  CLR     18C
0BC8:  RETURN  
.................... } 
....................  
.................... void PID_X_Y() { 
*
0E1E:  MOV     W5,[W15++]
0E20:  MOV     W6,[W15++]
0E22:  MOV     W7,[W15++]
0E24:  MOV     W8,[W15++]
....................     position[0] = En_x.Pulses * Position_Per_Pulse; //Times of twist for 1 round ****************Need Test for TIMES_PER_ROUND 
0E26:  MOV     840,W0
0E28:  CLR     W3
0E2A:  BTSC    W0.F
0E2C:  SETM    W3
0E2E:  MOV     W3,W1
0E30:  MOV     W3,W2
0E32:  CALL    2C2
0E36:  MOV     #F255,W4
0E38:  MOV     #769C,W5
0E3A:  MOV     #1B2F,W6
0E3C:  MOV     #4004,W7
0E3E:  CALL    326
0E42:  MOV     W0,W5
0E44:  MOV     W1,W6
0E46:  MOV     W2,W7
0E48:  MOV     W3,W8
0E4A:  MOV     W5,[W15++]
0E4C:  MOV     W6,[W15++]
0E4E:  MOV     W7,[W15++]
0E50:  PUSH    42
0E52:  BCLR.B  81.7
0E54:  SETM.B  42
0E56:  BSET.B  81.7
0E58:  MOV     W5,W0
0E5A:  MOV     W6,W1
0E5C:  MOV     W7,W2
0E5E:  MOV     W8,W3
0E60:  MOV     #0,W4
0E62:  MOV     #0,W5
0E64:  MOV     #0,W6
0E66:  MOV     #4079,W7
0E68:  CALL    436
0E6C:  BCLR.B  81.7
0E6E:  POP     42
0E70:  BSET.B  81.7
0E72:  MOV     [--W15],W7
0E74:  MOV     [--W15],W6
0E76:  MOV     [--W15],W5
0E78:  CALL    53E
0E7C:  MOV     W1,84E
0E7E:  MOV     W2,850
....................     drive[0] = UpdatePID(&Motor_X, (plantCommand[0] - position[0]), position[0]); 
0E80:  BSET.B  43.0
0E82:  PUSH    42
0E84:  BCLR.B  81.7
0E86:  SETM.B  42
0E88:  BSET.B  81.7
0E8A:  MOV     846,W0
0E8C:  MOV     848,W1
0E8E:  MOV     84E,W2
0E90:  MOV     850,W3
0E92:  CALL    582
0E96:  BCLR.B  81.7
0E98:  POP     42
0E9A:  BSET.B  81.7
0E9C:  MOV     W0,W5
0E9E:  MOV     W1,W6
0EA0:  PUSH    42
0EA2:  BCLR.B  81.7
0EA4:  SETM.B  42
0EA6:  BSET.B  81.7
0EA8:  MOV     #806,W4
0EAA:  MOV     W4,8CE
0EAC:  MOV     W5,8D0
0EAE:  MOV     W6,8D2
0EB0:  PUSH    84E
0EB2:  POP     8D4
0EB4:  PUSH    850
0EB6:  POP     8D6
0EB8:  CALL    858
0EBC:  BCLR.B  81.7
0EBE:  POP     42
0EC0:  BSET.B  81.7
0EC2:  MOV     W0,856
0EC4:  MOV     W1,858
0EC6:  PUSH    42
0EC8:  BCLR.B  81.7
0ECA:  SETM.B  42
0ECC:  BSET.B  81.7
....................     Control_Motor(DRIVE_MOTOR_X, drive[0]); 
0ECE:  MOV     #1,W4
0ED0:  MOV     W4,8C0
0ED2:  PUSH    856
0ED4:  POP     8C2
0ED6:  PUSH    858
0ED8:  POP     8C4
0EDA:  CALL    980
0EDE:  BCLR.B  81.7
0EE0:  POP     42
0EE2:  BSET.B  81.7
....................  
....................     position[1] = En_y.Pulses * Position_Per_Pulse; //Times of twist for 1 round ****************Need Test for TIMES_PER_ROUND 
0EE4:  MOV     844,W0
0EE6:  CLR     W3
0EE8:  BTSC    W0.F
0EEA:  SETM    W3
0EEC:  MOV     W3,W1
0EEE:  MOV     W3,W2
0EF0:  CALL    2C2
0EF4:  MOV     #F255,W4
0EF6:  MOV     #769C,W5
0EF8:  MOV     #1B2F,W6
0EFA:  MOV     #4004,W7
0EFC:  CALL    326
0F00:  MOV     W0,W5
0F02:  MOV     W1,W6
0F04:  MOV     W2,W7
0F06:  MOV     W3,W8
0F08:  MOV     W5,[W15++]
0F0A:  MOV     W6,[W15++]
0F0C:  MOV     W7,[W15++]
0F0E:  PUSH    42
0F10:  BCLR.B  81.7
0F12:  SETM.B  42
0F14:  BSET.B  81.7
0F16:  MOV     W5,W0
0F18:  MOV     W6,W1
0F1A:  MOV     W7,W2
0F1C:  MOV     W8,W3
0F1E:  MOV     #0,W4
0F20:  MOV     #0,W5
0F22:  MOV     #0,W6
0F24:  MOV     #4079,W7
0F26:  CALL    436
0F2A:  BCLR.B  81.7
0F2C:  POP     42
0F2E:  BSET.B  81.7
0F30:  MOV     [--W15],W7
0F32:  MOV     [--W15],W6
0F34:  MOV     [--W15],W5
0F36:  CALL    53E
0F3A:  MOV     W1,852
0F3C:  MOV     W2,854
....................     drive[1] = UpdatePID(&Motor_Y, (plantCommand[1] - position[1]), position[1]); 
0F3E:  BSET.B  43.0
0F40:  PUSH    42
0F42:  BCLR.B  81.7
0F44:  SETM.B  42
0F46:  BSET.B  81.7
0F48:  MOV     84A,W0
0F4A:  MOV     84C,W1
0F4C:  MOV     852,W2
0F4E:  MOV     854,W3
0F50:  CALL    582
0F54:  BCLR.B  81.7
0F56:  POP     42
0F58:  BSET.B  81.7
0F5A:  MOV     W0,W5
0F5C:  MOV     W1,W6
0F5E:  PUSH    42
0F60:  BCLR.B  81.7
0F62:  SETM.B  42
0F64:  BSET.B  81.7
0F66:  MOV     #822,W4
0F68:  MOV     W4,8CE
0F6A:  MOV     W5,8D0
0F6C:  MOV     W6,8D2
0F6E:  PUSH    852
0F70:  POP     8D4
0F72:  PUSH    854
0F74:  POP     8D6
0F76:  CALL    858
0F7A:  BCLR.B  81.7
0F7C:  POP     42
0F7E:  BSET.B  81.7
0F80:  MOV     W0,85A
0F82:  MOV     W1,85C
0F84:  PUSH    42
0F86:  BCLR.B  81.7
0F88:  SETM.B  42
0F8A:  BSET.B  81.7
....................     Control_Motor(DRIVE_MOTOR_Y, drive[1]); 
0F8C:  MOV     #2,W4
0F8E:  MOV     W4,8C0
0F90:  PUSH    85A
0F92:  POP     8C2
0F94:  PUSH    85C
0F96:  POP     8C4
0F98:  CALL    980
0F9C:  BCLR.B  81.7
0F9E:  POP     42
0FA0:  BSET.B  81.7
0FA2:  MOV     [--W15],W8
0FA4:  MOV     [--W15],W7
0FA6:  MOV     [--W15],W6
0FA8:  MOV     [--W15],W5
0FAA:  RETURN  
.................... } 
....................  
.................... /*volatile float leftPulses = 0; 
.................... volatile float leftPrevPulses = 0; 
.................... volatile float leftPwmDuty = 1.0; 
.................... volatile float leftVelocity = 0.0; 
....................  
.................... volatile float rightPulses = 0; 
.................... volatile float rightPrevPulses = 0; 
.................... volatile float rightPwmDuty = 1.0; 
.................... volatile float rightVelocity = 0.0;*/ 
....................  
....................  
.................... void main() { 
*
1404:  MOV     #2780,W15
1406:  MOV     #27FF,W0
1408:  MOV     W0,20
140A:  NOP     
140C:  MOV     #4444,W0
140E:  MOV     W0,A8
1410:  BSET.B  81.7
1412:  MOV     #46,W0
1414:  MOV.B   W0L,742
1416:  MOV     #57,W0
1418:  MOV.B   W0L,742
141A:  BCLR.B  742.6
141C:  MOV     #83F,W0
141E:  MOV     W0,680
1420:  MOV     #3F0C,W0
1422:  MOV     W0,6A4
1424:  MOV     #1312,W0
1426:  MOV     W0,6C0
1428:  MOV     #1400,W0
142A:  MOV     W0,6C8
142C:  MOV     #300,W0
142E:  MOV     W0,6CC
1430:  MOV     #46,W0
1432:  MOV.B   W0L,742
1434:  MOV     #57,W0
1436:  MOV.B   W0L,742
1438:  BSET.B  742.6
143A:  MOV     #8000,W4
143C:  MOV     W4,220
143E:  MOV     #400,W4
1440:  MOV     W4,222
1442:  BSET.B  220.3
1444:  MOV     #1A0,W4
1446:  MOV     W4,228
1448:  CLR     85E
144A:  CLR     874
144C:  MOV     #1,W4
144E:  MOV     W4,87E
1450:  BCLR.B  880.0
1452:  BCLR.B  880.1
1454:  SETM    32C
1456:  CLR     800
1458:  CLR     846
145A:  CLR     848
145C:  CLR     84A
145E:  CLR     84C
1460:  CLR     84E
1462:  CLR     850
1464:  CLR     852
1466:  CLR     854
1468:  CLR     856
146A:  CLR     858
146C:  CLR     85A
146E:  CLR     85C
1470:  CLR     876
1472:  CLR     878
1474:  CLR     87A
1476:  CLR     87C
1478:  CLR.B   881
....................     disable_interrupts(GLOBAL); 
147A:  BCLR.B  81.7
147C:  MOV     #E0,W4
147E:  MOV     W4,42
1480:  BSET.B  81.7
....................     clear_interrupt(INT_RDA); 
1482:  REPEAT  #3
1484:  MOV     226,W0
1486:  BCLR.B  85.3
....................     Init_Interrupts(); 
1488:  CALL    BA0
....................     Init_MotorPWM(); 
148C:  CALL    BAC
....................     enable_interrupts(GLOBAL); 
1490:  BCLR.B  81.7
1492:  CLR     42
1494:  BSET.B  81.7
....................  
....................     //ADC 
....................     Init_ADC(); 
1496:  CALL    BD4
....................     Change_ADC_Read_Channel(0); 
149A:  CLR     88A
149C:  CALL    BCA
....................  
....................     //Encoder 
....................     Encoder_Init(&En_x); 
14A0:  MOV     #83E,W4
14A2:  MOV     W4,88A
14A4:  CALL    BEA
....................     Encoder_Init(&En_y); 
14A8:  MOV     #842,W4
14AA:  MOV     W4,88A
14AC:  CALL    BEA
....................  
....................     //PID 
....................     PID_Init(&Motor_X, Kc, Ti, Td); 
14B0:  MOV     #806,W4
14B2:  MOV     W4,88A
14B4:  CLR     88C
14B6:  MOV     #3F00,W4
14B8:  MOV     W4,88E
14BA:  CLR     890
14BC:  CLR     892
14BE:  MOV     #CCCD,W4
14C0:  MOV     W4,894
14C2:  MOV     #3D4C,W4
14C4:  MOV     W4,896
14C6:  CALL    C08
....................     PID_Init(&Motor_Y, Kc, Ti, Td); 
14CA:  MOV     #822,W4
14CC:  MOV     W4,88A
14CE:  CLR     88C
14D0:  MOV     #3F00,W4
14D2:  MOV     W4,88E
14D4:  CLR     890
14D6:  CLR     892
14D8:  MOV     #CCCD,W4
14DA:  MOV     W4,894
14DC:  MOV     #3D4C,W4
14DE:  MOV     W4,896
14E0:  CALL    C08
....................  
....................     int Z_Position = 0; 
14E4:  CLR     882
....................  
....................     printf("Main\r\n"); 
14E6:  MOV     #0,W1
14E8:  MOV     W1,W0
14EA:  CLR.B   1
14EC:  CALL    200
14F0:  INC     W1,W1
14F2:  BTSC.B  223.1
14F4:  BRA     14F2
14F6:  MOV     W0,224
14F8:  MOV     #5,W0
14FA:  CPSGT   W1,W0
14FC:  BRA     14E8
....................     while (TRUE) { 
....................         int temp = read_adc(); 
14FE:  BCLR.B  320.0
1500:  BSET.B  320.1
1502:  BTSS.B  320.0
1504:  BRA     1502
1506:  PUSH    300
1508:  POP     884
....................         if (temp != 0) 
150A:  CP0     884
150C:  BRA     Z,1512
....................             Z_Position = temp; 
150E:  PUSH    884
1510:  POP     882
....................  
....................         if (state == TRUE) { 
1512:  BTSS.B  880.1
1514:  BRA     15F8
....................             int int_buffer = atoi(SM_Buffer); 
1516:  MOV     #860,W4
1518:  MOV     W4,88A
151A:  CALL    C82
151E:  MOV     W0,886
....................             if (isX == TRUE) 
1520:  BTSS.B  880.0
1522:  BRA     1558
....................                 data[0] = int_buffer / 1000.0; 
1524:  MOV     886,W0
1526:  CLR     W3
1528:  BTSC    W0.F
152A:  SETM    W3
152C:  MOV     W3,W1
152E:  MOV     W3,W2
1530:  CALL    2C2
1534:  PUSH    42
1536:  BCLR.B  81.7
1538:  SETM.B  42
153A:  BSET.B  81.7
153C:  MOV     #0,W4
153E:  MOV     #0,W5
1540:  MOV     #4000,W6
1542:  MOV     #408F,W7
1544:  CALL    436
1548:  BCLR.B  81.7
154A:  POP     42
154C:  BSET.B  81.7
154E:  CALL    53E
1552:  MOV     W1,876
1554:  MOV     W2,878
1556:  BRA     158A
....................             else 
....................                 data[1] = int_buffer / 1000.0; 
1558:  MOV     886,W0
155A:  CLR     W3
155C:  BTSC    W0.F
155E:  SETM    W3
1560:  MOV     W3,W1
1562:  MOV     W3,W2
1564:  CALL    2C2
1568:  PUSH    42
156A:  BCLR.B  81.7
156C:  SETM.B  42
156E:  BSET.B  81.7
1570:  MOV     #0,W4
1572:  MOV     #0,W5
1574:  MOV     #4000,W6
1576:  MOV     #408F,W7
1578:  CALL    436
157C:  BCLR.B  81.7
157E:  POP     42
1580:  BSET.B  81.7
1582:  CALL    53E
1586:  MOV     W1,87A
1588:  MOV     W2,87C
....................             plantCommand[0] = data[0]; 
158A:  PUSH    876
158C:  POP     846
158E:  PUSH    878
1590:  POP     848
....................             plantCommand[1] = data[1]; 
1592:  PUSH    87A
1594:  POP     84A
1596:  PUSH    87C
1598:  POP     84C
....................  
....................             PID_X_Y(); 
159A:  CALL    E1E
....................  
....................             state = FALSE; 
159E:  BCLR.B  880.1
....................  
....................             printf("%e  %e  %d\r\n", plantCommand[0], plantCommand[1], Z_Position); 
15A0:  MOV     848,W2
15A2:  MOV     846,W1
15A4:  MOV     #0,W0
15A6:  CALL    FAC
15AA:  MOV     #204,W4
15AC:  CALL    FF2
15B0:  BTSC.B  223.1
15B2:  BRA     15B0
15B4:  MOV     #20,W4
15B6:  MOV     W4,224
15B8:  BTSC.B  223.1
15BA:  BRA     15B8
15BC:  MOV     #20,W4
15BE:  MOV     W4,224
15C0:  MOV     84C,W2
15C2:  MOV     84A,W1
15C4:  MOV     #0,W0
15C6:  CALL    FAC
15CA:  MOV     #204,W4
15CC:  CALL    FF2
15D0:  BTSC.B  223.1
15D2:  BRA     15D0
15D4:  MOV     #20,W4
15D6:  MOV     W4,224
15D8:  BTSC.B  223.1
15DA:  BRA     15D8
15DC:  MOV     #20,W4
15DE:  MOV     W4,224
15E0:  MOV     882,W0
15E2:  MOV     #0,W4
15E4:  CALL    130E
15E8:  BTSC.B  223.1
15EA:  BRA     15E8
15EC:  MOV     #D,W4
15EE:  MOV     W4,224
15F0:  BTSC.B  223.1
15F2:  BRA     15F0
15F4:  MOV     #A,W4
15F6:  MOV     W4,224
....................             //printf("%d   %d\r\n",En_x.B_signal,En_y.B_signal); 
....................         } 
15F8:  BRA     14FE
....................     } 
.................... } 
....................  
15FA:  PWRSAV  #0

Configuration Fuses:
   Word  1L: 3F7F   WPOSTS16 WDT128 WINDIS NOWDT ICSP1 NODEBUG NOWRT NOPROTECT NOJTAG
          H: FF00  
   Word  2L: F9F7   NOPR NOALTI2C1 IOL1WAY NOOSCIO FRC_PLL SOSC_SEC WUT_DEFAULT IESO
          H: FF00  
